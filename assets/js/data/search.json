[ { "title": "[ ComfyUI ] CuiBox 소개", "url": "/posts/comfyui_cuibox/", "categories": "A.I., ComfyUI", "tags": "ComfyUI, AI, 인공지능, CuiBox, Windows, Desktop", "date": "2024-12-05 08:00:00 +0900", "snippet": "Contents CuiBox 설치 방법 설정 CuiBox.json 트레이 메뉴 마무리CuiBoxCuiBox는 윈도우(Windows) 환경 하에서 ComfyUI를 좀 더 편리하게 사용하기 위해 만들고 있는 프로그램입니다. 최근에 ComfyUI에서 일렉트론을 이용한 Desktop App을 출시하고 있는 것으로 알고 있습니다. 하지만 방향이 약간 다른 관계로 CuiBox 프로젝트는 계속 진행하려고 합니다. 그럼 CuiBox에 대해 간단하게 살펴 보겠습니다.설치 방법 https://github.com/comfyanonymous/ComfyUI/releases에서 최근 버전의 ComfyUI_windows_portable_nvidia.7z 파일을 다운로드 합니다. https://github.com/MonosLab/CuiBox에서 Code &gt; Download Zip을 클릭하여 다운로드 합니다. ComfyUI_windows_portable_nvidia.7z 파일을 적당한 위치에 압축 해제 합니다. CuiBox에서 다운로드한 zip 파일을 압축 해제 후 ComfyUI_windows_portable 폴더 아래에 붙여 넣습니다. CuiBox.exe 파일을 실행합니다. 설정환경 설정은 CuiBox.json 파일을 직접 수정하시거나, 트레이 메뉴를 이용하여 변경하실 수 있습니다. 먼저 CuiBox.json 파일을 이용하는 방법을 알려드리겠습니다.CuiBox.json{\t\"lang\": \"ko\",\t\"mode_comment\": \"h(horizontal) or v(vertical)\",\t\"mode\": \"horz\",\t\"run_comment\": \"cpu, gpu (* for Nvidia)\",\t\"run\": \"cpu\",\t\"auto_update\": true} lang : 언어는 현재 한국어(ko), 영어(en), 중국어(zh), 일본어(ja), 베트남어(vi)를 제공하고 있습니다. mode : 콘솔 창의 배치 옵션입니다. 오른쪽(horz)이나 아래(vert)에 배치할 수 있습니다. run : NVIDIA 그래픽 카드를 사용하고 있는 경우 gpu를 그 외에는 cpu를 사용하여 ComfyUI를 이용할 수 있습니다. auto_update : CuiBox를 자동 업데이트 할지에 대한 옵션입니다. 기본은 true입니다. (이 부분은 트레이 메뉴에서 제공하지 않습니다.)트레이 메뉴작업표시줄 우측에 트레이 아이콘에서 ⓒ 모양의 아이콘(CuiBox 아이콘)에 마우스 커서를 위치시키고 우측 버튼을 누르면, 트레이 메뉴가 나타나며 구성은 아래와 같습니다. 열기 : 숨겨진 CuiBox를 다시 열기 위한 메뉴입니다. 트레이 아이콘을 더블 클릭하는 효과와 동일합니다. 윈도우 시작시 자동 실행 : 윈도우가 시작될 때 CuiBox를 자동으로 실행되도록 하는 옵션입니다. 초기화 : CuiBox를 초기 윈도우 사이즈로 변경합니다. (향후 제거 예정) 변경된 설정 적용 : custom nodes 설치 후 cuibox(comfyui)를 재시작합니다. 실행 모드 : CuiBox.json의 mode 설정을 CPU 또는 GPU로 변경합니다. (설정 후 변경된 설정 적용 필요) 언어 선택 (Language) : CuiBox.json의 lang 설정을 ko, en, zh, ja, vi로 변경합니다. (설정 후 변경된 설정 적용이 필요하지 않음)마무리아직은 계속 개발을 진행하여 가는 과정이므로, 향후에는 어떠한 모습으로 변하게 될지는 모르지만 윈도우즈(Windows)에서 ComfyUI를 사용하는데 있어서 편리하게 이용할 수 있도록 기능들을 추가해 나가겠습니다." }, { "title": "[ ComfyUI ] 프롬프트", "url": "/posts/comfyui_prompt/", "categories": "A.I., ComfyUI", "tags": "ComfyUI, AI, 인공지능, 프롬프트, Prompt", "date": "2024-08-25 08:00:00 +0900", "snippet": "Contents 프롬프트 기본 작성법 키워드 괄호와 대괄호 중괄호 직접 가중치 부여 AND 연산 프롬프트 처리 및 토큰의 제한 효과적인 프롬프트 작성하기 결론프롬프트프롬프트는 AI 시스템이 수행해야 할 창의적인 작업이나, 생성해야 할 창의적인 콘텐츠의 방향을 결정하기 위해 전달하는 입력(명령) 또는 지시문을 말합니다. 프롬프트는 작성 방법에 따라 생성되는 콘텐츠의 스타일이나 품질, 내용 등이 크게 달라 질 수가 있습니다. 아래는 프롬프트가 통상적으로 가지는 중요한 역활을 나열한 것입니다.1. 작업의 목적과 범위 정의 2. 출력 형상과 스타일 지정 3. AI의 행동 및 응답 방식 지정 4. 특정 정보나 지식의 활용을 지시 여기서는 이미지 생성을 위한 인공지능 모델인 스테이블 디퓨전(Stable Diffusion)에서 사용하는 프롬프트 작성법에 대해 알아 보겠습니다. 아래에 설명할 기본 작성법을 잘 활용하면 효과적인 프롬프트 작성이 가능하며, 이는 바로 응답에 대한 품질을 높여 줄 것이며, 원하는 결과에 근접한 이미지를 얻을 수 있도록 도울 것입니다.기본 작성법프롬프트는 구체성 구체적으로 작성되어야 하며, 명료성 모호한 내용이나 불필요한 단어를 사용하지 않으면서 명확해야 하며, 간결성 간결하게 표현하고, 연관성 원하는 주제 또는 장면에 맞는 적절한 키워드나 문구를 선정하여야 합니다.키워드프롬프트를 작성할 때 문장으로 나열하기 보다는 핵심 키워드를 사용하여 간단하고 명료하게 작성하는 것이 스테이블 디퓨전 모델에서는 이해하기 쉬워 원하는 결과를 얻는데 더 효과적입니다. 예를 들면 girl passing by snack corner라는 문장보다는 snack corner, girl, passing by와 같이 키워드를 콤마(,)로 구분하여 표현하는 것이 더 좋습니다. 프롬프트의 키워드 작성 순서는 이미지 생성에 영향을 미치지는 않습니다. 그렇지만 순서를 변경하면 처리 순서가 변경되어 생성되는 이미지도 바뀌게 됩니다. 어디에서 보면, 생성하고자 하는 이미지에서 가중치를 주어야하는 키워드는 앞부분에 배치하라고 권장하고 있습니다. 이는 더 많은 가중치가 부여되는 것이 아니라, 한 번에 처리 가능한 프롬프트의 수에는 제한 때문에 뒤에 가면 적용이 되지 않을 수 있기 때문에 오인한 것으로 판단이 됩니다. 예를 들면 snack corner, girl, passing by와 girl, snack corner, passing by는 다른 결과의 이미지를 얻습니다. snack corner를 가장 앞에 둔 프롬프트의 경우 전자의 girl과 후자의 girl은 동등한 가중치를 부여 받지만 위치에 따라 생성되는 이미지는 약간의 차이를 보입니다. 아래에서 설명할 대괄호나 괄호, 숫자 등의 표기법으로 가중치를 부여하지 않는 한은 생성에 참조하는 키워드 순서에 따라 처음 참조 키워드가 무엇이냐에 따라 가중치를 부여받는 듯한 인상을 줍니다.괄호와 대괄호Stable diffusion은 사용자가 생성하고자 하는 이미지에 최대한 가깝게 하기 위해 프롬프트를 세부적으로 조정할 수 있는 다양한 방법을 제공합니다. 특정 키워드를 여러번 반복적으로 사용하여 확률을 높여 가중치를 높여 줄 수는 있지만, 한정된 토큰과 불필요한 토큰 처리를 줄여주기 위해 아래에 제시된 몇가지 방법을 사용합니다. 그 중 하나가 괄호와 대괄호입니다. 특정 단어나 문장을 강조하고자 할 때는 괄호 기호((, ))를 사용합니다. 괄호가 있는 경우 더 가중치가 높게 적용되며, 괄호의 중첩이 많을 수록 더 가중치가 증가하게 됩니다. 예를 들면, snack corner, ((girl)), (beauty), passing by와 같이 프롬프트를 작성하였다면, girl, beauty, snack corner, passing by의 순서로 가중치가 부여됩니다. 아무 기호가 없는 것은 기본 가중치인 1.0의 가중치를 부여 받습니다. 이와 반대로 대괄호 기호([, ])는 감싸고 있는 해당 키워드의 가중치를 평균(1.0)보다 적게 부여합니다. 예를 들면, girl, [beauty], snack corner, [[passing by]]와 같이 프롬프트를 작성하였다면, girl, snack corner, beauty, passing by의 순서로 가중치를 부여 받습니다. ()는 가중치를 높이고 싶을때, []는 가중치를 낮추고 싶을때 사용합니다. 괄호와 대괄호는 각각 10%씩의 가중치를 증가/감소 시킵니다. 예를 들면 ((키워드))와 [[키워드]]는 각각 1.1 x 1.1 = 1.21과 0.9 x 0.9 = 0.81의 가중치를 얻습니다.중괄호이미지를 생성할 때 중괄호({, })를 이용하여 랜덤하게 키워드를 선택하게 할 수도 있습니다. 예를 들면, {girl|boy}, snack corner, passing by와 같이 프롬프트를 작성하였다면, girl 또는 boy는 Queue에서 랜덤하게 선택하게 됩니다. 즉, 스낵 코너를 지나는 소년 또는 소녀의 이미지가 랜덤하게 생성될 것입니다.직접 가중치 부여위의 괄호나 대괄호처럼 상대적으로 가중치를 부여할 수도 있으나, 사용자가 직접 가중치를 부여할 수도 있습니다. 예를 들면, snack corner, (girl:1.1), (beauty:0.5), passing by(1.2)라 프롬프트를 작성하였다면, passing by, girl, snack corner, beauty의 순으로 가중치를 부여 받지만, beauty의 속성은 적용되지 않을 확률이 높습니다. 또 다른 가중치에 가중치를 부여하는 다른 예를 살펴 보겠습니다. snack corner, (girl:1.1), ((beauty:1.0): 1.3), passing by로 프롬프트를 작성하면, beauty, girl, snack corner, passing by의 순서로 높은 가중치가 부여 됩니다. beauty의 경우 1.0 x 1.3 = 1.3의 가중치를 부여 받기 때문에 girl의 1.1보다 더 높은 가중치를 부여 받습니다. ComfyUI에서는 단축키로도 가중치를 증/감시킬 수 있습니다. Ctrl + Up키, Ctrl + Down 키를 사용하여 편리하게 사용할 수도 있습니다.AND 연산2개 이상의 키워드를 결합할 때는 AND 연산자를 사용합니다. 연산자라고 해서 특별한 기호가 있는 것이 아니라 키워드와 키워드 사이에 and 를 입력하면 됩니다. 예를 들면, “girl and boy”와 같이 프롬프트를 작성하면 됩니다. 이와 같이 하면 소녀와 소년이 함께 있는 이미지를 얻습니다. 물론 100% 보장은 되지 않지만 둘이 함께 나올 확률을 높여 줍니다.프롬프트 처리 및 토큰의 제한Stable diffusion v1 모델은 최대 75개의 토큰으로 정해져 있습니다. 토큰 = 키워드로 일치하지는 않습니다.(즉, 키워드가 10개라고해서 10개의 토큰이 생성되는 것은 아닙니다.) CLIP 모델에서 프롬프트를 자동적으로 토큰으로 변환하는데, 처리 중 익숙하지 않은 키워드가 발견되면 추가 분석을 통해 해당 키워드와 유사 또는 익숙한 키워드로 쪼개어 토큰을 분류합니다. AUTOMATIC1111에서는 사실상 토큰 길이 제한이 없습니다. 75보다 많은 토큰이 있다면 새로운 토큰 그룹을 만들어서 150, 225와 같이 계속 증가시킵니다. ComfyUI에서도 CLIP 모델의 토큰 제한을 확장시킬 수가 있으며, CLIP-L 모델을 이용하여 최대 248개로 확장시킬 수 있습니다.효과적인 프롬프트 작성하기위에서 가중치나 연산자 또는 토큰 등의 활용에 대해 알아봤습니다. 이제는 어떻게 하면 스테이블 디퓨전 프롬프트를 효과적으로 작성하여서 우리가 원하는 이미지를 얻을 수 있을지에 대해 공부해야합니다. 효과적인 프롬프트를 생성하려면 원하는 이미지의 구체적인 키워드 선정과 복잡성을 고려하는 것이 중요합니다. 선정 및 고려해야 할 몇 가지 측면은 아래와 같습니다: 주제에 맞는 포괄 키워드 선정 사람, 동식물 또는 풍경과 같이 이미지에 표현하고자 하는 포괄할 수 있는 특징적인 키워드를 통해 먼저 분류 합니다. 행동 또는 형상 키워드 선정 포괄 키워드의 행동이나 형상에 관한 키워드를 선정합니다. 예를 들면 서 있거나 앉아 있는 자세, 우아함 또는 화려함 등과 같이 포괄 키워드의 상태를 나타내는 키워드가 그것들 입니다. 맥락 또는 묘사 키워드 선정 행동 또는 형상에 대한 세부 서술적 키워드들을 추가합니다. 예를 들면 해변에 앉아 있는 사람과 같이 포괄 키워드와 행동 키워드를 한정해 줄 수 있는 “해변에”와 같은 한정적 묘사 키워드를 추가합니다. 광원 또는 조명 기법 키워드 선정 해당 키워드는 주요한 요소는 아니지만, 광원이나 조명을 추가하여 좀 더 사실적인 이미지 생성을 돕습니다. 이미지 AI 모델을 이용하여 효과적인 프롬프트를 작성하기 위해서는 위에 나열한 요소를 적절히 활용하면 가능합니다.위의 내용은 아래와 같이 한 줄 요약할 수 있습니다. 생성하려는 이미지의 포괄적 키워드를 찾고, 그 다음에 해당 키워드의 행동이나 형상을 선정한 후 이에 대한 묘사를 하고, 세부적인 요건들을 나열하는 것이 효과적인 프롬프트를 작성하는 방법입니다.결론프롬프트와 관련하여 다양하게 알아보았습니다. 프롬프트를 적절하게 작성하고 활용하는 것은 AI 이미지 생성에 있어서 매우 중요하며, 많은 시행착오를 요구 합니다. 원하는 이미지를 얻기 위해서는 프롬프트 작성에 의존해야하기 때문에 자주 그리고 많이 작성하여 보는 것이 도움이 될 것입니다. 위의 내용들을 참고하여 다들 원하시는 이미지를 생성하기를 바래봅니다." }, { "title": "[ RUST ] 스마트 포인터 (smart pointer)", "url": "/posts/rust_smartpoint/", "categories": "프로그래밍, RUST", "tags": "RUST, smart, point, 스마트, 포인터", "date": "2024-08-09 08:00:00 +0900", "snippet": "Contents 스마트 포인터 Box&lt;T&gt; Rc&lt;T&gt; Arc&lt;T&gt; Cell&lt;T&gt; 과 RefCell&lt;T&gt; 나만의 스마트 포인터스마트 포인터스마트 포인터는 메모리의 주소 값을 가지는 변수, 즉 포인터에 추가적으로 데이터의 소유와 메타 데이터의 기능도 가지고 있는 데이터 구조입니다. 스마트 포인터는 구조체(Struct) 타입으로 정의 하며, 포인터가 가르키는 값을 참조하기 위한 Deref와 참조한 값의 소유권을 잃을 때 호출될 Drop trait을 구현하여야 합니다.러스트의 대표적인 스마트 포인터로는 Box, Rc, Arc, Cell 등이 있으며, 아래와 같은 특징을 가집니다. 스마트 포인터 소유권 스레드 Box&lt;T&gt; 단일 소유권 싱글 스레드 Rc&lt;T&gt; 다중 소유권 싱글 스레드 Arc&lt;T&gt; 다중 소유권 멀티 스레드 Cell&lt;T&gt; 단일 소유권 싱글 스레드 Box&lt;T&gt;가장 직관적인 스마트 포인터이며, Box는 데이터를 스택이 아니라 힙에 저장할 수 있도록 해줍니다. 스택에 남는 것은 힙 데이터를 가리키는 포인터입니다. 컴파일시에 크기를 특정할 수 없는 데이터 타입을 가지고 있고, 데이터의 소유권을 이동시킬때 데이터의 복사가 일어나는 것을 원치 않을 경우, 그리고 스택에 큰 데이터를 저장할 때 스택 오버플로우가 예상되는 경우 사용하면 됩니다. &lt;사용 예시&gt;fn main() { let b = Box::new(5); println!(\"b = {}\", b);}Rc&lt;T&gt;러스트에서는 대부분의 소유자가 명확합니다. 그러나 하나의 제너릭 데이터 T에 대해 여러 소유자가 필요한 경우도 있습니다. 이럴 경우 소유권을 공유할 수 있는 Rc(Reference counted) 스마트 포인터를 사용하면 됩니다.&lt;사용 예시&gt;use std::rc::Rc;fn main() { let a = Rc::new(5); let b = Rc::clone(&amp;a); println!(\"a: {}, b: {}\", a, b);}Arc&lt;T&gt;Arc(Atomically reference counted)는 힙에 할당된 제너릭 데이터 T의 값을 다중 스레드 상황에서 안전하게 공유할 수 있도록 하는 스마트 포인터입니다. Arc는 참조 연산시 원자적 연산을 하게 되는데, 이는 메모리 접근 비용 보다 더 많은 비용을 소모하게 됩니다. 따라서 스레드 상황이 아니라면 Rc를 사용하는 것이 좋습니다. 원자적 연산이란 처리 중간에 다른 연산을 허용하지 않는 연산입니다. 다중 스레드 처리시 “이 만큼 했다”라는 모호함이 없고, 오직 “끝났다”와 “시작전이다”만 존재하는 연산입니다.&lt;사용 예시&gt;use std::sync::Arc;use std::thread;fn main() { let data = Arc::new(vec![1, 2, 3]); let dc1 = data.clone(); let dc2 = data.clone(); let handle1 = thread::spawn(move || { println!(\"data clone #1: {:?}\", dc1); }); let handle2 = thread::spawn(move || { println!(\"data clone #2: {:?}\", dc2); }); handle1.join().unwrap(); handle2.join().unwrap();}Cell&lt;T&gt; 과 RefCell&lt;T&gt;Cell, RefCell은 Box와 마찬가지로 단일 소유권을 가지는 스마트 포인터입니다. 단지 차이점은 Box는 제너릭 데이터 T를 가변적 변수로 사용할 수 없는데, 반해 Cell은 불변 변수를 가변 변수처럼 사용이 가능합니다. Cell은 어떤 데이터에 대한 불변 참조자가 있더라도 데이터를 변경할 수 있도록 내부 가변성(interior mutability) 디자인 패턴을 제공합니다. 그리고 RefCell의 경우는 데이터 변경이 아닌 참조를 이용하여 데이터를 변경하려고 하면 RefCell을 사용해야 합니다. &lt;사용 예시&gt;use std::cell::Cell;fn main() { let c = Cell::new(1); println!(\"set #1 : {}\", c.get()); c.set(2); println!(\"set #2 : {}\", c.get());}&lt;사용 예시&gt;use std::cell::RefCell;fn main() { let rc = RefCell::new(1); println!(\"borrow #1 : {}\", rc.borrow()); *rc.borrow_mut() += 2; println!(\"borrow #2 : {}\", rc.borrow());}나만의 스마트 포인터마지막으로 Box와 유사한 스마트 포인터를 구현하는 방법을 알아 보겠습니다.struct BoxEx&lt;T&gt;(T);impl&lt;T&gt; BoxEx&lt;T&gt; { fn new(x: T) -&gt; BoxEx&lt;T&gt; { BoxEx(x) }}Box&lt;T&gt;와 같이 제너릭 데이터 T를 사용하도록 하였고, new를 이용하여 힙에 데이터를 할당하도록 하였습니다. 다음으로 앞에서 잠깐 언급했던 Deref와 Drop을 아래와 같이 구현해 줍니다.use std::ops::Deref; impl&lt;T&gt; Deref for BoxEx&lt;T&gt; { type t = T; fn deref(&amp;self) -&gt; &amp;Self::t { &amp;self.0 }}fn main() { let a = 5; let b = BoxEx::new(a); println!(\"BoxEx value : {}\", b);}" }, { "title": "[ RUST ] 프로그램 시작시 콘솔창 숨기기", "url": "/posts/rust_hide_console/", "categories": "프로그래밍, RUST", "tags": "RUST, 러스트, 콘솔창, 숨기기, hide, console", "date": "2024-08-02 08:00:00 +0900", "snippet": "Contents 프로그램 시작시 콘솔창 숨기기프로그램 시작시 콘솔창 숨기기프로그램 실행시 콘솔창이 보이지 않게 하기 위한 방법에 대해 설명합니다. 먼저 Cargo.toml의 dependencies에 winapi 크레잇을 추가합니다.[dependencies]winapi = {version = \"0.3\", features = [\"wincon\", \"winuser\"]}다음으로 작업할 것은 콘솔창이 뜰때 핸들을 얻어와서 숨기는 작업을 해주어야 합니다. 아래의 hide_console_window() 함수는 핸들을 얻어와 윈도우를 숨기는 작업에 관한 내용입니다.fn hide_console_window() { use std::ptr; use winapi::um::wincon::GetConsoleWindow; use winapi::um::winuser::{ShowWindow, SW_HIDE}; let window = unsafe {GetConsoleWindow()}; if window != ptr::null_mut() { unsafe { ShowWindow(window, SW_HIDE); } }}위의 방법은 간단히 한줄로 표현할 수도 있습니다.fn hide_console_window() { unsafe { winapi::um::wincon::FreeConsole() };}두 방법 모두 콘솔창이 띄워졌을 때 바로 숨기는 작업을 합니다. 마지막으로 hide_console_window() 함수를 main 함수에서 호출해 주기만 하면 프로그램 시작시 콘솔창을 바로 숨겨주게 됩니다.fn main() {\thide_console_window();\tprintln!(\"hello, world!!!\");}단, 콘솔창에서 프로그램을 실행한 경우(즉, 파일탐색기에서 exe 파일을 실행한 경우가 아닌 경우)에는 콘솔의 소유가 실행한 프로그램이 아니기 때문에 콘솔창이 숨겨지지 않습니다. 일반적으로 파일탐색기(또는 단축아이콘)에서 실행하거나, 윈도우 시작시 자동실행 등은 위의 hide_console_window() 함수를 이용하면 콘솔창이 잘 숨겨지는 걸 확인 하실 수 있습니다." }, { "title": "[ RUST ] 개발시 유용한 도구들", "url": "/posts/rust_tools/", "categories": "프로그래밍, RUST", "tags": "RUST, 러스트, Visual Code, 도구", "date": "2024-07-18 08:00:00 +0900", "snippet": "Contents Visual Code Visual Code의 확장 프로그램 rust-analyzer CodeLLDB Dependi Rust Syntax Even Better TOM Rust Mod Generator Project Manager PowerShell Tauri Visual CodeRust 개발시 많이 사용하고 있는 도구입니다.Visual Code의 확장 프로그램rust-analyzer코드를 분석, 자동 완성 등의 기능을 제공하고 문제가 발생할 수 있는 부분을 사전에 차단하기 위한 해법을 제공하여 코드의 품질을 향상시킵니다.CodeLLDBlldb를 사용하여 디버깅을 할 수 있는 확장 툴로 브레이크 포인트 설정과 순차적(단계적) 디버깅을 할 수 있는 기능을 제공합니다. 러스트, C++, Kotlin, Swift 등의 언어에서 사용이 가능합니다.Dependi러스트의 crates.io 사이트에서 버전 정보를 얻어와 Cargo.toml 작성시 dependencies checking에 유용한 확장 프로그램입니다. 유사한 크레잇으로 crates이 있는데, 현재 개발이 중단된 것 같습니다.Rust Syntax러스트 코드의 Syntax를 화려하게 탈바꿈 시켜줍니다. 밋밋한 텍스트 기반의 코드를 자신만의 색상으로 화려하게 만들어 줄 수 있수 있는 도구입니다.Even Better TOM위의 Rust Syntax처럼 TOML 문서를 화려하게 탈바꿈 시켜줍니다. 또한 Validation 기능과 코드를 폴더블하게 닫았다 열었다하는 기능을 제공합니다. 그 외의 TOML 작성과 관련하여 많은 부가 기능들을 제공합니다.Rust Mod Generator러스트 모듈을 쉽게 생성할 수 있도록 돕는 도구입니다.Project Manager러스트의 프로젝트를 관리하기 용이 합니다. 물론 러스트가 아닌 프로젝트도 관리가 가능합니다.PowerShellVisual Studio Code의 터미널의 확장툴이며 여러개의 PowerShell을 실행시켜 사용할 수 있도록 돕습니다.Tauri데스크탑 어플리케이션을 빌드할 수 있는 툴킷입니다." }, { "title": "[ ComfyUI ] ComfyUI 설치", "url": "/posts/comfyui_install/", "categories": "A.I., ComfyUI", "tags": "ComfyUI, AI, install, 인공지능, 설치", "date": "2024-07-15 08:00:00 +0900", "snippet": "Contents ComfyUI 설치 모델 설치 checkpoints vae 기존 모델 사용하기ComfyUI 설치ComfyUI 설치 방법은 아주 쉽습니다. Github 저장소(https://github.com/comfyanonymous/ComfyUI#windows)으로 이동 하셔서 Direct link to download 라고 된 링크에서 파일을 다운로드 받고, 원하는 폴더에 압축을 풀기만 하면 됩니다. 그리고 아래에서도 설명하겠지만, 이미 AUTOMATIC1111을 사용하고 있다면 설치 해둔 LoRA, controlNet 파일을 공유하여 사용할 수 있습니다.모델 설치모델들은 CIVITAI 나 huggingface 또는 github 등에서 구하셔서 ComfyUI_windows_portable\\ComfyUI\\models에 있는 적절한 폴더에 넣어주시기만 하면 됩니다. 예를 들어 checkpoints 모델을 다운 받으셨다면, ComfyUI_windows_portable\\ComfyUI\\models\\checkpoints 폴더에 넣어 주시기만 하면 됩니다. 아래는 제가 자주 사용하는 기본 모델들의 다운로드 목록입니다.checkpoints ComfyUI_windows_portable\\ComfyUI\\models\\checkpoints 폴더에 저장 ✅ SDXL1.0 base 모델 sdXL_v10VAEFix.safetensors (https://civitai.com/api/download/models/128078) ✅ SDXL1.0 refiner 모델 sdXL_v10RefinerVAEFix.safetensors (https://civitai.com/api/download/models/128080) ✅ 실사모델 majicMIX realistic (https://civitai.com/models/43331/majicmix-realistic) ✅ 그림모델 anything (https://civitai.com/models/66/anything-v3)vae ComfyUI_windows_portable\\ComfyUI\\models\\vae 폴더에 저장 ✅ 실사VAE vae-ft-mse-840000-ema (https://huggingface.co/stabilityai/sd-vae-ft-mse-original/tree/main) ✅ 그림VAE KI-f8-anime (https://civitai.com/models/118561/anything-kl-f8-anime2-vae-ft-mse-840000-ema-pruned-blessed-clearvae-fp16cleaned)기존 모델 사용하기ComfyUI_windows_portable\\ComfyUI로 이동하면 extra_model_paths.yaml.example 파일이 있습니다. 편집기를 이용하여 오픈하시고 AUTOMATIC1111의 모델이 있는 곳의 위치를 설정하신 후 extra_model_paths.yaml로 새 이름으로 저장하시면 됩니다. base_path를 AUTOMATIC1111이 설치된 폴더로 지정하시면 됩니다.a111: base_path: 여기에 전체 경로로 입력합니다. (ex : c:/sd/stable-diffusion-webui) checkpoints: models/Stable-diffusion configs: models/Stable-diffusion vae: models/VAE loras: | models/Lora models/LyCORIS upscale_models: | models/ESRGAN models/RealESRGAN models/SwinIR embeddings: embeddings hypernetworks: models/hypernetworks controlnet: models/ControlNet" }, { "title": "[ ComfyUI ] ComfyUI에 대해", "url": "/posts/comfyui_struct/", "categories": "A.I., ComfyUI", "tags": "ComfyUI, AI, 인공지능", "date": "2024-07-09 08:00:00 +0900", "snippet": "Contents ComfyUI 란? 기본 구조 Load Checkpoint CLIP Text Encode (Positive/Negative) Empty latent image KSampler VAE Decode Save Image ComfyUI 란?ComfyUI는 스테이블 디퓨전(Stable diffusion) 모델의 요소들을 노드로 표현하여 생성, 연결하는 워크플로우를 제공하여 쉽게 이미지를 생성할 수 있도록 돕는 노드 기반의 GUI(Graphical User Interface) 도구입니다. 코드를 직접 작성할 필요가 없으며, 노드들의 연결만으로 스테이블 디퓨전을 이용할 수 있습니다. 그리고 데이터 흐름을 직접 볼 수 있어 사용자들에게 편리한 환경을 제공하고 워크플로우를 저장하고 불러 올 수 있어 워크플로우의 관리도 편리합니다. 위에 언급된 스테이블 디퓨전은 ComfyUI에 있어 중요한 부분이므로 간략하게 알고 넘어가겠습니다. Stability AI(Emad Mostaque가 설립한 회사)에서 독일 뮌헨 대학교 Machine Vision &amp; Learning Group (CompVis) 연구실의 “잠재 확산 모델을 이용한 고해상도 이미지 합성 연구”를 기반으로 Runway ML와 공동 개발한 것을 오픈소스 라이선스(CreativeML Open RAIL-M License)로 배포한 text-to-image 인공지능 모델입니다. 많은 이미지 생성 AI가 온라인으로 서비스를 제공(OpenAI의 Dall-e 2, 구글의 Imagen 등)하는데 반해, 스테이블 디퓨전은 개인 PC에서도 실행 가능하도록 컴퓨터 리소스 사용을 대폭 줄여 개발 되었습니다.기본 구조ComfyUI의 워크플로우는 노드(node)와 엣지(edge)로 구성되어 집니다. 노드는 아래의 그림에서 볼 수 있는 Load Checkpoint, Clip Text Encode, KSampler, VAE Decode 등의 박스들을 일컫습니다. 노드는 입력과 출력 인터페이스를 가지며 상자 내부에 보여지는 파라미터(설정) 값을 가집니다. 그리고 이들 노드와 노드를 연결하고 있는 선들을 엣지라고 부릅니다. 엣지는 노드의 흐름을 제어 해 준다고 보시면 됩니다. Load Checkpoint워크플로우의 시작은 체크포인트를 설정하는 것으로 부터 시작합니다. 체크포인트는 스테이블 디퓨전에서 사용할 모델을 선택하는 것입니다. ckpt_name 파라미터의 모델명을 클릭하면 사용 가능한 모델의 목록이 표시되며, 그 중 하나를 선택하여 모델을 적용할 수 있습니다.Load Checkponit node는 잠재 공간에서 노이즈를 예측하기 위한 모델(MODEL)과 긍정/부정 프롬프트를 처리하는 클립(CLIP) 그리고 픽셀과 잠재 공간 사이에서 이미지를 변환해주는 배(VAE)로 구성됩니다. MODEL : 잠재 공간의 노이즈 예측 모델이며, 스테이블 디퓨전에서는 U-net이라는 모델을 사용. CLIP : 긍정/부정 프롬프트(CLIP Text Encode (Prompt))와 연결. VAE : 가변 자동 인코더로 픽셀을 잠재 공간 이미지로 변환.CLIP Text Encode (Positive/Negative)CLIP Text Encode 노드는 입력된 프롬프트에서 단어를 추출하고 해당 단어들을 CLIP 언어 모델에서 매칭된 토큰으로 변환합니다. CLIP Text Encode는 긍정과 부정의 두개의 프롬프트를 입력 받습니다. 긍정(positive) 프롬프트는 생성되는 이미지에 포함되어야 할 내용들이며, 부정(negative) 프롬프트는 이미지 생성시 제외되어야 할 내용들을 입력합니다. 그리고 작성된 각각의 프롬프트는 KSampler 노드에 positive와 negative에 맞게 연결을 해주시면 됩니다. Empty latent imageEmpty latent image 노드는 잠재 공간(latent space)에 빈 이미지 공간을 생성합니다. 이때 노드에 설정된 latent image의 크기와 동일하게 잠재 공간이 생성됩니다. 그리고 batch_size라는 필드에 값에 따라 한번에 생성할 이미지의 갯수를 지정할 수 있습니다. 여기에 10을 설정하면 한번에 10장의 이미지를 생성합니다. KSamplerKSampler는 잠재 공간의 이미지에서 아래의 설정한 값에 의존하여 노이즈를 제거해 가는 과정을 반복합니다. 파라미터는 아래에 내용과 같은 기능을 수행합니다. seed : 무작위 시드 값은 잠재 공간 이미지의 초기 노이즈와 최종 이미지의 구성을 컨트롤 합니다. control_after_generate : 초기 시드를 설정합니다. 랜덤하게 임의의 값을 지정하거나 시드를 고정하여 사용할 수 있습니다. steps : 샘플링하는 단계의 수입니다. 생성된 이미지의 남은 노이즈 제거 정도에 따라 단계의 수를 증가 또는 감소 시켜 주어 적절한 값을 주어야 합니다. cfg : 프롬프트 적용에 대한 자유도 입니다. 높은 값을 입력하면 프롬프트의 내용을 지키려는 확률이 높고, 낮추게 되면 무시하려는 확률이 높아집니다. sampler_name : 샘플링 알고리즘을 설정합니다. scheduler : 각 단계의 노이즈 변경 방법을 제어합니다. denoise : 초기 노이즈를 얼마 만큼 줄지를 설정합니다. 1.00인 경우 잡음이 최대로 추가 됩니다. 이 node에서는 잠재 이미지(latent image)를 샘플링하여 생성합니다. 잠재 이미지를 실제 이미지로 변경하려면 LATENT와 VAE Decode를 연결하여 줍니다.VAE DecodeVAE(가변 자동 인코더, Variable Automatic Encoder) Decode 노드는 잠재 이미지를 실제 이미지로 바꾸어 줍니다. Save Image마지막으로 VAE Decode를 통해 생성된 실제 이미지를 저장하는 노드입니다. filename_prefix는 생성될 파일명이며, 생성된 순서에 따라 prefix명에 순차적 숫자가 부여되어 파일이 저장됩니다. 저장되는 경로는 comfyui가 설치된 경로의 output 폴더에 저장이 됩니다. " }, { "title": "툴박스2 (1차 개발)", "url": "/posts/naonsoft-012/", "categories": "", "tags": "", "date": "2024-06-11 09:00:00 +0900", "snippet": "툴박스 (with RUST) - 1차 기간 : 2024.05.01 ~ 2024.07.31■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, RUST 1차 개발 (2024.05.01 ~ 2024.07.31)✔️ 환경설정 ✔️ 버전 비교 ✔️ Tray / Menu ✔️ HTTP 통신 ✔️ Named PIPE Server ✔️ 실행(UAC 포함)2차 개발✔️ 시스템 정보 ✔️ 로그(디버깅 포함) ✔️ 프로세스 관리(실행/종료) ✔️ 라이선스 정보 관리 ✔️ 플러그인기존 툴박스에 몇가지 기능을 더 추가한 버전이며, 기존 C++로 개발되었던 부분을 RUST 언어로 대체하는 과도기적 관리 툴을 개발합니다. 점진적으로 RUST로 완전 대체할 예정입니다." }, { "title": "[ RUST ] 앱 정보 추가 및 관리자 실행 권한 부여", "url": "/posts/rust_set_file_info/", "categories": "프로그래밍, RUST", "tags": "RUST, 버전, 라이선스, 앱 정보, 실행 권한, UAC", "date": "2024-04-25 08:00:00 +0900", "snippet": "Contents 앱 정보 추가하기 Cargo.toml 셋팅 앱 아이콘 설정 및 관리자 권한으로 실행 앱 정보 추가하기winres 크레잇을 이용하여 앱의 속성에 표시되는 정보들을 입력하는 방법에 대해 알아 보려고 합니다. 복잡하지 않으니 아래의 순서대로만 따라하시면 쉽게 앱의 속성을 추가하실 수 있습니다.Cargo.toml 셋팅[package]name = \"winres_sample\"version = \"1.0.0\"edition = \"2021\"build = \"build.rs\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[package.metadata.winres]FileDescription = \"descript\"#FileVersion = \"1.0.0.0\"ProductName = \"ToolBox\"ProductVersion = \"1.0.0.1\"LegalCopyright = \"© 2024 Monoslab. All rights reserved.\"OriginalFilename = \"ToolBox.exe\"CompanyName = \"Monoslab\"Comments = \"Monoslab ToolBox\"InternalName = \"MonoslabToolBox.exe\"[dependencies]...[build-dependencies]winres = \"0.1\"위와 같이 [build-dependencies]에 winres = “0.1”을 추가하고 [package.metadata.winres] … 를 추가합니다.FileVersion은 주석 처리를 하였는데, 이는 [package]의 version이 우선시 되기 때문에 FileVersion에 어떠한 값을 추가하여도 [package]의 version값으로 표시가 되기 때문입니다. 입력 후 빌드를 해 보시고 생성된 실행 파일의 “속성 &gt; 자세히”를 선택하시면 아래와 같이 내용들이 추가 되어 있는 것을 확인 하실 수 있습니다.앱 아이콘 설정 및 관리자 권한으로 실행앱의 실행 파일 아이콘 및 관리자 권한으로 앱을 실행하도록 설정하기 위해서는 Cargo.toml 파일이 있는 폴더에 build.rs 파일과 assets 폴더 및 toolbox.ico 파일을 생성하고 아래의 예제와 같이 작업을 해줍니다.extern crate winres;const DEF_MANIFEST: &amp;str = r#\"&lt;assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"&gt;&lt;trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v3\"&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=\"requireAdministrator\" uiAccess=\"false\" /&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt;&lt;/trustInfo&gt;&lt;/assembly&gt;\"#;fn main() { if cfg!(target_os = \"windows\") { let mut res = winres::WindowsResource::new(); res.set_icon(\"assets/toolbox.ico\"); res.set_manifest(DEF_MANIFEST); res.compile().unwrap(); }}build.rs를 저장하고 cargo build --release를 입력하여 빌드합니다.정상적으로 빌드가 되었다면 실행파일의 아이콘이 assets 폴더에 추가했던 아이콘으로 변경이 되고 아이콘 우측하단에 방패 모양(관리자 권한 실행 적용)이 생긴 것을 볼 수 있을 것입니다." }, { "title": "[ RUST ] 포맷터(Formatter)와 린터(Linter)", "url": "/posts/rust_formatter_and_linter/", "categories": "프로그래밍, RUST", "tags": "RUST, 포맷터, 린터, formatter, linter", "date": "2024-03-04 08:00:00 +0900", "snippet": "Contents Rust 표준 포맷터(Formatter)와 린터(Linter) Rust 표준 포맷터(Formatter) : rustfmt Rust 표준 린터(Linter) : clippy Rust 표준 포맷터(Formatter)와 린터(Linter)2019년 6월 Tidelift와 The New Stack에서 소프트웨어 개발자를 대상으로 설문조사를 한 내용으로 보면, 새 코드를 작성하거나 기존 코드를 개선하는데 32%의 시간을 사용하고 코드 유지 관리를 위해 19%, 그 외 테스트나 보안 문제 대응에 16%를 사용한다고 합니다. (* 참조 사이트 : https://thenewstack.io/how-much-time-do-developers-spend-actually-writing-code/ )이 통계를 보면 소프트웨어 개발자들은 평균 51% 정도의 시간에 코드를 개발/개선 또는 유지 관리를 위해 할애하고 있습니다. 이처럼 짧은 시간에 효율적인 코딩을 하기 위해서는 일관된 코딩 스타일로 작업하는 것이 필수적입니다. 협업을 하는 경우에는 더더욱 그러하구요. 일관된 코드는 가독성을 높여 적은 노력과 적은 시간으로 원하는 결과를 얻어 낼 수가 있기 때문입니다. 일관된 코드를 작성하기 위해서는 어떠한 규칙을 정하고 정한 규칙에 대해 올바르게 따르고 있는지 확인해 줄 도구가 필요한데, 이 도구가 포맷터와 린터입니다. 포매터와 린터에 규칙을 잘 세워두면 일관된 코드를 만드는데 도움이 됩니다. 포매터(Formatter) : 작성한 코드를 정해진 규칙(들여쓰기 등)에 따라 코드 스타일을 교정하기 위한 도구. 린터(Linter) : 코드의 구조를 검사해서 버그가 날 수 있을 만한 코드, 스타일 오류, 의심스러운 구조 등을 찾아주는 도구. 일관된 코드 스타일을 유지하려면 포맷터를 …, 코드의 구조와 잠재적 문제를 해결하려면 린터를 사용하라! Rust 표준 포맷터(Formatter) : rustfmt개개인의 다양한 코딩 스타일로 코딩된 코드를 Rust 팀에서 개발한 rustfmt을 이용하여 정형화된 코드 스타일을 유지할 수 있게 해줍니다. 아래와 같은 방법으로 설치를 합니다.\\&gt; rustup component add rustfmt사용은 아래와 같이 명령을 실행해 줍니다.\\&gt; cargo fmt위의 명령이 잘 수행되었다면, 소스 코드를 열어 아름답게 정리(?)된 코드를 확인 하실 수 있을 것입니다.이외에도 Cargo.toml 파일에 ‘rustfmt-nightly = “1.4.21”‘를 추가하고 코드 내에서 정리가 필요하지 않은 부분들은 설정을 통해 skip등의 작업을 수행할 수도 있습니다. (자세한 내용은 https://crates.io/crates/rustfmt-nightly 를 참조 하세요.)Rust 표준 린터(Linter) : clippy프로그래밍 언어에는 잠재적 문제를 유발할 수 있는 코드나 추천 하지 않는 방법을 사용하는 경우를 체크해서 경고하여 주는 린트(lint)라는 프로그램이 있습니다. Python의 pylint나 ECMAScript의 eslint 처럼 Rust에서도 Clippy라는 린터가 존재합니다. Rust의 1.78.0 버전 미만에서는 아래와 같은 방법으로 설치를 합니다. (1.78.0 버전 이상부터는 포함되어 배포되기 때문에 별도로 설치하지 않습니다.)\\&gt; rustup component add clippy아래의 명령을 실행해 줍니다.\\&gt; cargo clippy이외에도 Cargo.toml 파일에 ‘clippy = “0.0.302”’ (0.0.302는 사용할 버전)를 추가해 주고 코드 내에서 clippy와 관련하여 경고나 특정 코드를 허용할 수도 있습니다. (자세한 내용은 https://github.com/rust-lang/rust-clippy#clippy 를 참조 하세요.) clippy를 사용하면, 추천하지 않는 방법으로 코딩한 경우에는 아래와 같은 경고와 해결 방안에 대해서 친절히 안내 받을 수 있습니다.warning: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let` --&gt; src\\main.rs:53:44 |53 | .on_system_tray_event(|app, event| match event { | ____________________________________________^54 | | SystemTrayEvent::MenuItemClick { id, .. } =&gt; match id.as_str() {55 | | \"quit\" =&gt; {56 | | std::process::exit(0);... |68 | | _ =&gt; {}69 | | }) | |_________^ | = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#single_match = note: `#[warn(clippy::single_match)]` on by defaulthelp: try this |53 ~ .on_system_tray_event(|app, event| if let SystemTrayEvent::MenuItemClick { id, .. } = event { match id.as_str() {54 + \"quit\" =&gt; {55 + std::process::exit(0);56 + }57 + \"settings\" =&gt; {58 + let window = app.get_window(\"main\").unwrap();59 + window.emit(\"trayEvent\", \"settings\").unwrap();60 + }61 + \"refresh\" =&gt; {62 + let window = app.get_window(\"main\").unwrap();63 + window.emit(\"trayEvent\", \"refresh\").unwrap();64 + }65 + _ =&gt; {}66 ~ } }) | 린터(Linter)는 코드의 품질을 향상 시켜주어 현장에서 많이 사용되고 있는 도구이지만 실제로는 너무 엄격한 잣대로 인해 오히려 많은 개발 시간을 투자하게 만들지도 모릅니다. 하지만 그 보다 더 큰 잇점인 코드의 품질 향상이나 일관성, 가독성 등을 높여주기 때문에 사용하는 것을 권장합니다." }, { "title": "[ VC++ ] 트레이 팝업 메뉴의 외부 클릭시 메뉴가 사라지지 않는 문제 해결", "url": "/posts/cpp_tray_menu/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, MFC, tray, menu, outside, click", "date": "2024-02-19 00:00:00 +0900", "snippet": "Contents 트레이 팝업 메뉴의 외부 클릭시 메뉴가 사라지지 않는 문제 해결트레이 팝업 메뉴의 외부 클릭시 메뉴가 사라지지 않는 문제 해결윈도우 프로그래밍시 트레이 아이콘을 자주 사용하곤 하는데, 이때 트레이 아이콘에서 TrackPopupMenu 함수를 이용하여 팝업 메뉴를 띄웠을때 메뉴 영역 밖을 클릭 했을 경우 사라지는 경우도 있고 그렇지 않은 경우도 심심찮게 발생되는 것을 확인 할 수 있습니다.보통 트레이 아이콘 개발시 마우스 클릭 이벤트가 발생할 경우 아래와 같이 많이 코딩을 합니다.LRESULT CXXXXDlg::OnTrayIcon(WPARAM wParam, LPARAM lParam){\tHWND hWnd = GetSafeHwnd();\tswitch (lParam)\t{\t\t... [ 생략 ] ...\t\tcase WM_RBUTTONDOWN:\t\t{\t\t\tCPoint pt;\t\t\tHMENU hMenu = CreatePopupMenu();\t\t\tHMENU hSubMenu = CreatePopupMenu();\t\t\tGetCursorPos(&amp;pt);\t\t\tAppendMenu(hSubMenu, MF_STRING, UDM_LANG_KO, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_KOREAN));\t\t\t...\t\t\tAppendMenu(hSubMenu, MF_STRING, UDM_LANG_VI, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_VIETNAMESE));\t\t\tCheckMenuItem(hSubMenu, UDM_LANG_KO, MF_CHECKED);\t\t\tEnableMenuItem(hSubMenu, UDM_LANG_KO, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);\t\t\tAppendMenu(hMenu, MF_POPUP | MF_STRING, (UINT_PTR)hSubMenu, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_SELECT_LANGUAGE));\t\t\tAppendMenu(hMenu, MF_SEPARATOR, NULL, NULL);\t\t\tAppendMenu(hMenu, MF_STRING, UDM_CLOSE, CResourceEx::GetInstance()-&gt;LoadStringEx(IDT_EXIT));\t\t\tTrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);\t\t\tDestroyMenu(hSubMenu);\t\t\tDestroyMenu(hMenu);\t\t}\t\tbreak;\t}\treturn 0L;}위와 같은 방법으로 팝업 메뉴를 띄운 경우 hWnd가 최상단에 위치한 경우에는 정상적으로 Popup menu가 사라지겠지만, 아닌 경우에는 메뉴의 외부를 클릭하더라도 그대로 존재함을 확인 할 수 있습니다. 아래와 같이 ::SetForegroundWindow(hWnd); 한 줄만 추가 하면 이런 문제를 해결 할 수 있습니다. 구글링을 해보면 질문은 많이 있는데, 솔루션을 제시한 글이 없는것 같네요.LRESULT CXXXXDlg::OnTrayIcon(WPARAM wParam, LPARAM lParam){\tHWND hWnd = GetSafeHwnd();\tswitch (lParam)\t{\t\t... [ 생략 ] ...\t\tcase WM_RBUTTONDOWN:\t\t{\t\t\tCPoint pt;\t\t\tHMENU hMenu = CreatePopupMenu();\t\t\tHMENU hSubMenu = CreatePopupMenu();\t\t\tGetCursorPos(&amp;pt);\t\t\tAppendMenu(hSubMenu, MF_STRING, UDM_LANG_KO, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_KOREAN));\t\t\t...\t\t\tAppendMenu(hSubMenu, MF_STRING, UDM_LANG_VI, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_VIETNAMESE));\t\t\tCheckMenuItem(hSubMenu, UDM_LANG_KO, MF_CHECKED);\t\t\tEnableMenuItem(hSubMenu, UDM_LANG_KO, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);\t\t\tAppendMenu(hMenu, MF_POPUP | MF_STRING, (UINT_PTR)hSubMenu, CResourceEx::GetInstance()-&gt;LoadStringEx(IDS_SELECT_LANGUAGE));\t\t\tAppendMenu(hMenu, MF_SEPARATOR, NULL, NULL);\t\t\tAppendMenu(hMenu, MF_STRING, UDM_CLOSE, CResourceEx::GetInstance()-&gt;LoadStringEx(IDT_EXIT));================================================================&gt;&gt;\t\t\t::SetForegroundWindow(hWnd);================================================================\t\t\tTrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);\t\t\tDestroyMenu(hSubMenu);\t\t\tDestroyMenu(hMenu);\t\t}\t\tbreak;\t}\treturn 0L;}" }, { "title": "[ VC++ ] 부모가 비활성인 경우, 버튼 클릭 이벤트 문제 해결", "url": "/posts/cpp_button_click_event/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, MFC, 커스텀 버튼, 이벤트, 마우스, Custom button, event, mouse, LButtonDown", "date": "2024-01-19 00:00:00 +0900", "snippet": "Contents 커스텀 버튼(Cutsomizing button)의 마우스 클릭 문제 해결커스텀 버튼(Cutsomizing button)의 마우스 클릭 문제 해결CButton을 상속받아 커스텀 버튼을 만든 이후에 버튼의 부모 윈도우가 비활성(Lost focus, Deactive) 상태에 있는 경우 버튼을 클릭하면 포커스만 되고 클릭 이벤트가 발생(WM_LBUTTONDOWN/WM_LBUTTONUP는 커스텀 버튼에서 정상적으로 이벤트가 발생됨)하였으나 버튼과 연결된 함수는 호출되지 않는 현상이 발생하였습니다. 원인은 마우스 이동을 감지하기 위해 OnMouseMove() 함수에서 사용한 SetCapture/ReleaseCapture 함수가 원인인 것으로 추정이 됩니다.(SetCapture/ReleaseCapture 함수를 사용하지 않은 경우 정상적으로 원클릭으로 작동됨을 확인함)하지만 버튼 위에 마우스 오버시 버튼을 그려주어야 하기 때문에 사용하지 않을 수는 없는 상황이어서 아래와 같은 방법처럼 마우스가 버튼 내에 있는 경우라면 포커스를 주도록 설정하였습니다. 윈도우가 비활성된 상태에서 버튼을 클릭하면 이벤트는 발생이 되나 버튼과 연결된 함수는 호출되지 않고, 활성화 된 상태에서는 정상적으로 함수가 호출 되는 문제를 해결한 방법입니다. 이와 유사한 경우가 발생되는 경우에도 Set focus와 Release focus를 적절히 활용하여 해결을 할 수 있을 것으로 판단됩니다.변경 전void CXRoundedButton::OnMouseMove(UINT nFlags, CPoint point) { CRect rcClient; GetClientRect(rcClient);\t // Check, if Mouse is on Control if (rcClient.PtInRect(point)) { bool bRedrawNeeded = !m_bMouseOnButton;\t // Mouse is on Control m_bMouseOnButton = true; // Set Capture to recognize, when the mouse leaves the control SetCapture();\t // Redraw Control, if Button is hot if (m_bIsHotButton) Invalidate(); } else { // We have lost the mouse-capture, so the mouse has left the buttons face m_bMouseOnButton = false; // Mouse has left the button ReleaseCapture(); // Redraw Control, if Button is hot if (m_bIsHotButton) Invalidate(); } CButton::OnMouseMove(nFlags, point); } 변경 후void CXRoundedButton::OnMouseMove(UINT nFlags, CPoint point) { CRect rcClient; GetClientRect(rcClient);\t // Check, if Mouse is on Control if (rcClient.PtInRect(point)) { bool bRedrawNeeded = !m_bMouseOnButton;\t // Mouse is on Control m_bMouseOnButton = true; if (GetCapture() != this) { // Set Capture to recognize, when the mouse leaves the control SetCapture(); // Redraw Control, if Button is hot if (m_bIsHotButton) Invalidate(); // Set focus SendMessage(WM_SETFOCUS); } } else { // We have lost the mouse-capture, so the mouse has left the buttons face m_bMouseOnButton = false; // Mouse has left the button ReleaseCapture(); // Redraw Control, if Button is hot if (m_bIsHotButton) Invalidate(); // Kill focus SendMessage(WM_KILLFOCUS); } CButton::OnMouseMove(nFlags, point); } " }, { "title": "[ Project ] 사전 업데이트(Pre-patch) 설계 및 개발", "url": "/posts/partial_update/", "categories": "프로젝트", "tags": "프로젝트, pre-patch, 업데이트, update, partial, download, 분할 다운로드", "date": "2023-10-13 06:00:00 +0900", "snippet": "Contents Overview 사전 업데이트(Pre-patch) 설계 장/단점 ⭕ (1안) 다중 다운로드 ⭕ (2안) 순차적 다운로드 (선택) 버전 비교 및 업데이트 다운로드 실패시 처리 방안 기타 Overview사전 업데이트는 대용량의 파일을 낮은 네트워크 대역폭에서 이용하거나, 출근 시간대에 동시에 많은 사용자가 다운로드를 하는 경우에 네트워크 트래픽의 분산을 하기 위한 용도로 만들어졌습니다. 툴박스 업데이트는 사전 업데이트와 정식 업데이트로 구성이 됩니다. 물론 상황에 따라서는 사전 업데이트 없이 정식 업데이트만으로 구성하여 사용할 수도 있습니다. 사전 업데이트는 정식 업데이트와의 시간 차이가 크면 클수록 정식 업데이트시에 업데이트 파일을 다운받기 위해 서버로 몰리는 병목현상을 줄여 줄 수 있습니다. 사전 업데이트는 분할 다운로드를 지원하며 정식 업데이트는 연속된 스트리밍 데이터를 저장하도록 되어 있습니다. 이런 방법으로 개발이 된 이유는 사전 다운로드의 경우에는 정식 업데이트 이전까지는 이전 버전 그대로 사용하기 때문에 파일을 분할하여 다운로드 받더라도 서비스에는 영향을 주지 않습니다. 하지만 정식 업데이트시에는 업데이트가 이루어짐과 동시에 바뀐 서비스를 이용하여야 하기 때문에 분할 다운로드가 아닌 스트리밍 방식으로 처리를 하고 있습니다. 사전 업데이트와 정식 업데이트간의 시간 차이가 클수록 정식 업데이트시 서버로의 업데이트 파일 요청의 수가 현저히 줄어 듭니다.사전 업데이트(Pre-patch) 설계대용량의 파일을 업데이트 하는 경우에 한번에 접속이 몰려 네트워크의 트래픽을 유발할 수 있어 백그라운드에서 사전에 업데이트 파일을 다운로드 하여 처리하기 위해 2가지의 방안을 가지고 설계하였으며 두 방안 모두 분할 다운로드(Partial download) 방법을 사용하였습니다.2가지 방안(다중 다운로드와 순차적 다운로드)의 장/단점은 아래와 같으며, 프로그램의 복잡도를 최소화하고 이어받기가 용이한 (2안)을 채택하여 프로젝트에 적용하였습니다.장/단점⭕ (1안) 다중 다운로드 전체 파일 사이즈를 얻어와서 빈 파일을 생성하고 분할 다운로드한 데이터를 씀 실패한 경우 실패 목록에 저장하고 다음 범위의 데이터를 요청함. 마지막까지 데이터 요청이 끝난 경우 다시 실패한 목록을 요청하여 다운로드 함. 모두 다운로드가 된 경우 요청한 프로그램에 통지.[장점] ✅ 다중 다운로드가 가능(멀티쓰레드 이용)[단점] ✅ 분할 데이터 중 완료된 데이터에 대한 관리가 필요함. ✅ 완료되지 않고 중단된 파일은 재 시작시 다시 다운로드 하여야 함.(이를 관리하게 되면 프로그램 복잡도가 상승함)⭕ (2안) 순차적 다운로드 (선택) 임시 폴더에 파일을 생성하고, 분할 다운로드한 데이터를 씀. 실패한 경우 일정 시간 경과 후 다시 재 요청을 함. (http에러에 대한 처리 필요; 4xx, 5xx 에러의 경우 설정에 따라 중지 유무 판단) 모두 다운로드가 된 경우 요청한 프로그램에 통지.[장점] ✅ 분할 데이터에 대한 관리가 필요 없음. ✅ 완료되지 않고 중단된 파일을 이어 받기에 용이함.[단점] ✅ 순차적으로 다운로드해야 함. (멀티쓰레드 사용 불가)버전 비교 및 업데이트 업데이트는 사전 업데이트(백그라운드에서 진행)와 일반적인 업데이트(즉시 진행) 두가지를 병행하여 작동합니다. 사전 업데이트가 있는 경우에는 사용자가 인지하지 못하게 백그라운드에서 다운로드를 진행하고 일반적인 업데이트는 즉시 서버 또는 사전 다운로드 된 파일로 업데이트가 진행됩니다.위의 그림을 살펴보면 그룹웨어 서버에는 Pre-patch용과 patch용 버전 파일 및 업데이트 파일이 존재하며 두 파일의 용도는 아래와 같습니다. Pre-patch ver.msp : 사전 다운로드를 위한 버전 정보 파일입니다. files : 사전에 업데이트 될 파일을 로컬의 임시 폴더에 저장해 두기 위한 파일입니다. Patch ver.ms : 업데이트 버전 정보를 담고 있습니다. files : 현재의 버전 정보(ver.ms)와 일치하는 업데이트 파일입니다. 사전 업데이트 파일이 있는 경우 업데이트 시점에 사전 업데이트 파일로 교체됩니다. (수동으로 작업)프로그램 실행시 서버의 업데이트 폴더의 버전 파일(ver.ms)과 로컬에 있는 버전 파일(ver.ms)을 먼저 비교를 하게 됩니다. 버전이 동일한 경우에는 프로그램을 실행하고 일치하지 않는 경우에는 사전 다운로드된 파일의 유무에 따라 아래의 방법으로 업데이트를 진행하게 됩니다. 사전 다운로드 된 파일이 있는 경우 사전 다운로드된 파일이 있는 경우 완료가 된 파일에 한해 toolbox 폴더 아래로 이동 사전 다운로드가 완료되지 않은 파일은 서버에서 직접 다운로드 진행 사전 다운로드 된 파일이 없는 경우 서버에서 직접 다운로드 진행프로그램이 정상적으로 실행된 이후에는 주기적으로 서버에 사전 업데이트가 있는지 체크하고 사전 업데이트가 필요한 경우에는 사전 다운로드 관리 파일(dn.json)을 생성하고 관리 파일 명 버전 정보 총 파일의 크기 및 현재 다운로드된 파일의 크기 다운로드 완료 유무 Pre-patch 파일 다운로드 를 진행하게 됩니다. 전체 흐름 요약 다운로드 실패시 처리 방안분할 다운로드(Partial download)시 실패(S0~S1 구간)한 경우에는 현재까지 다운로드 완료한 크기를 얻어와 이전에 다운로드 완료한 부분(S0)에서 부터 S1까지 재 요청하여 다운로드를 수행합니다. 이러한 방법을 통해 프로그램이 재시작하더라도 이어받기가 가능해 집니다.기타서버는 분할 다운로드된 파일의 유효성 체크를 위해 파일에 대한 Hash 정보를 제공합니다." }, { "title": "사전 업데이트(Pre-patch)", "url": "/posts/naonsoft-011/", "categories": "", "tags": "", "date": "2023-10-10 09:00:00 +0900", "snippet": "대용량 업데이트 기능 개선 기간 : 2023.10 ~ 2024.01■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, Http(Partial download) ✔️ 백그라운드 업데이트 프로그램: 6 M/d - 환경 설정 및 버전 체크 . 메이저 버전 패치 : 목표 날짜에 무조건 업그레이드가 모두 되어야 사용가능. . 마이너 버전 패치 : 목표날짜 없이 천천히 백그라운드에서 패치. - 나온톡과의 통신 - 생명주기 ✔️ 분할 다운로드 : 10 M/d ✔️ 재접속 다운로드 : 5 M/d ✔️ CRC : 5 M/d 체크 파일 생성 파일의 무결성 체크 ✔️ 다운로드 목록 관리 및 완료 처리 : 5 M/d ✔️ 안정화 : 10 M/dS고객사에서 3000명 이상이 동시에 몰려 대용량 파일을 업데이트 하는 문제가 발생하였으며, 이때 많은 사용자가 30여분간 불편을 겪었습니다.이를 해결 하기 위해 대용량 파일의 업데이트가 있는 경우에는 사전에 백그라운드에서 업데이트 파일을 미리 다운받아 설치하는 방안이 필요하게 되었습니다. 원리는 Partial download 방법으로 분할하여 데이터를 내려 받고, 향후 정식 업데이트시 사전에 내려 받은 파일로 바꿔치기 하는 방법으로 구현되었습니다." }, { "title": "[ VC++ ] 타이틀바가 없는 윈도우 최대화", "url": "/posts/cpp-get-taskbar-in-monitor/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, taskbar, maximize, 작업표시줄, 최대화", "date": "2023-09-14 00:00:00 +0900", "snippet": "Contents Taskbar의 위치에 따른 윈도우의 최대화Taskbar의 위치에 따른 윈도우의 최대화다이얼로그 베이스에서 타이틀바를 제거하고 윈도우의 최대화시 하단에 taskbar가 있는 경우에는 문제가 발생하지 않지만, 위쪽 또는 왼쪽에 위치하는 경우 문제가 발생됨을 확인하였습니다. Windows OS에서 알아서 해주면 참 좋을텐데, 그렇지 못한 것이 참 아쉽습니다. 그리고 또 멀티 모니터의 경우에도 또 다른 문제가 발생되어 수동으로 윈도우의 최대화시 위치를 보정하고 사이즈를 잡아주기 위해 아래와 같이 작업을 하였습니다. 이래 저래 손이 많이 가는 타이틀바가 없는 경우의 윈도우 최대화 작업이었네요. ^^#define PX_CALIBRATE\t\t-7#define PX_TASKBAR_HEIGHT\t32void CMonoslabDlg::PreSubclassWindow(){\tDWORD dwStyle = /*WS_OVERLAPPED |*/ WS_THICKFRAME | WS_CLIPSIBLINGS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SIZEBOX;\tModifyStyle(WS_CAPTION, dwStyle, SWP_FRAMECHANGED);\tCDialogEx::PreSubclassWindow();}void CMonoslabDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI){\tHMONITOR hMon = MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);\tMONITORINFOEX mi;\tmi.cbSize = sizeof(MONITORINFOEX);\tGetMonitorInfo(hMon, &amp;mi);\t\tRECT rc\t\t\t= mi.rcWork;\t\t// workarea rectangle\tRECT rcm\t\t= mi.rcMonitor;\t\t// monitor rectangle\tUINT nWorkAreaHeight\t= rc.bottom - rc.top;\tUINT nWorkAreaWidth\t= rc.right - rc.left;\tUINT nMonitorHeight\t= rcm.bottom - rcm.top;\tUINT nMonitorWidth\t= rcm.right - rcm.left;\t// Get taskbar info.\tif ((nMonitorHeight - nWorkAreaHeight) &gt;= PX_TASKBAR_HEIGHT)\t{\t\tlpMMI-&gt;ptMaxPosition.x = PX_CALIBRATE;\t\tlpMMI-&gt;ptMaxPosition.y = rc.top + PX_CALIBRATE;\t}\telse if (nMonitorWidth - nWorkAreaWidth &gt;= PX_TASKBAR_HEIGHT)\t{\t\tlpMMI-&gt;ptMaxPosition.x = rc.left + PX_CALIBRATE;\t\tlpMMI-&gt;ptMaxPosition.y = PX_CALIBRATE;\t}\tlpMMI-&gt;ptMaxSize.x = rc.right - rc.left + 15;\t// 그림자 여백(20) 보정\tlpMMI-&gt;ptMaxSize.y = rc.bottom - rc.top + 17;\t// 37 - 그림자 여백(20) 보정\tlpMMI-&gt;ptMinTrackSize.x = WND_MIN_X;\t\t// 윈도우 최소 넓이\tlpMMI-&gt;ptMinTrackSize.y = WND_MIN_Y;\t\t// 윈도우 최소 높이\tCDialogEx::OnGetMinMaxInfo(lpMMI);}윈도우의 최대화시 lpMMI-&gt;ptMaxPosition.x와 lpMMI-&gt;ptMaxPosition.y의 값은 기본 -7 입니다. 이를 보정하기 위해 PX_CALIBRATE(-7)을 정의하고 각 위치에 반영하였습니다. OnGetMinMaxInfo() 함수의 경우 윈도우의 변동이 발생될 경우 매번 호출이 되기 때문에 윈도우가 어느 모니터에 있던지 최대화시 작업영역(Workarea)을 얻어와 정확한 위치를 찾아 최대화 할 수 있었습니다. 이때 PX_TASKBAR_HEIGHT(32) 값으로 작업표시줄의 위치 유무를 판단한 근거는 작업표시줄의 높이는 최소 32여서 그 이상이면 작업표시줄이 있는 것으로 판단하였습니다." }, { "title": "[ VC++ ] 작업표시줄(Taskbar)의 프로그램 아이콘 클릭시 최소화 되지 않는 문제 해결", "url": "/posts/cpp-taskbar-click-to-minimize/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, taskbar, minimize, 작업표시줄, 최소화", "date": "2023-09-12 00:00:00 +0900", "snippet": "Contents Taskbar의 아이콘 클릭시 최소화가 되지 않는 문제 해결 방법Taskbar의 아이콘 클릭시 최소화가 되지 않는 문제 해결 방법다이얼로그 베이스에서 타이틀바를 제거하고 프로그램을 만들일이 있어서 개발하여 잘 사용하고 있었습니다. 그런데 어느날 보니 taskbar의 프로그램 아이콘을 클릭하면 프로그램이 상단으로 올라 오는 것은 잘되나 다시 한번 클릭하면 최소화가 되지 않고 멀똥 멀똥 저를 쳐다 보는 다이얼로그를 발견하게 되었습니다. “아 무언가 잘못 되었구나”바로 소스를 이리 저리 살펴 보아도 별로 문제되는 것이 없어 보였습니다. ‘아무래도 타이틀바를 없앤 것과 무슨 연관이 있을텐데…’여기까지 생각이 미치자 곧바로 한 곳이 생각이 났습니다.void CMonoslabDlg::PreSubclassWindow(){\t// borderless shadow\tDWORD dwStyle = WS_THICKFRAME | WS_CLIPSIBLINGS;\tModifyStyle(WS_CAPTION, dwStyle, SWP_FRAMECHANGED);\tCDialogEx::PreSubclassWindow();}역시나 코드는 거짓이 없다라는 걸 깨닫는 순간이었습니다. 원래의 다이얼로그의 기본 style을 완전히 무시하고 내가 원하는 style(WS_THICKFRAME, WS_CLIPSIBLINGS)만 집어 넣었던 것입니다. 아래와 같이 최소화(WS_MINIMIZEBOX)와 최대화(WS_MAXIMIZEBOX)를 style에 추가한 이후에야 taskbar 클릭시 창이 앞으로 뜨고, 다시 눌렀을 때 비로소 최소화가 되었습니다.void CMonoslabDlg::PreSubclassWindow(){\tDWORD dwStyle = WS_THICKFRAME | WS_CLIPSIBLINGS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;\t// borderless shadow\tModifyStyle(WS_CAPTION, dwStyle, SWP_FRAMECHANGED);\tCDialogEx::PreSubclassWindow();}만약 윈도우의 기본 속성을 모두 상속하여 처리 하고 싶다면, GetStyle() 함수를 이용하여 현재의 스타일을 가져온 이후에 스타일을 추가 또는 삭제하시고 ModifyStyle(…) 함수를 호출하여 주시면 됩니다." }, { "title": "[ VC++ ] CImage 클래스를 이용하여 PNG 파일을 그릴때 깨지는 문제 해결", "url": "/posts/cpp-draw-png-file/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, png, alpha, draw", "date": "2023-08-29 00:00:00 +0900", "snippet": "Contents CImage 클래스를 이용한 Draw 일반적으로 이미지를 로딩하고 그려주는 경우 이미지를 읽어와서 보정 후 그려주는 경우 CImage 클래스를 이용한 DrawCImage 클래스를 이용하여 화면에 이미지를 출력할 경우 투명 영역을 처리할 때 아래와 같은 “일반적으로 이미지를 로딩하고 그려주는 경우” 방법으로 이미지를 로드하고 알파값을 처리해주면 이미지 깨짐 현상이 발생됩니다. 이미지의 깨짐없이 처리하기 위해서는 약간의 작업을 해주어야 하는데, 아래 이미지는 처리 전과 처리 후의 모습을 보여주는 이미지입니다.일반적으로 이미지를 로딩하고 그려주는 경우void CMonosoftDlg::OnPaint(){ CClientDC dc(this); CDC dcMem; dcMem.CreateCompatibleDC(&amp;dc); int nX = 0; int nY = 0; CBitmap bitmap; CImage img; if(img.Load(_T(\"C:\\\\img.png\") == S_OK) { nX = img.GetWidth(); nY = img.GetHeight(); bitmap.Attach(img.Detach()); CBitmap *pOldBmp = dcMem.SelectObject(&amp;bitmap); BLENDFUNCTION bfImage = { AC_SRC_OVER, 0x00, 0xFF, AC_SRC_ALPHA }; AlphaBlend(dc.GetSafeHdc(), 100, 100, nX, nY, dcMem.GetSafeHdc(), 0, 0,nX, nY, bfImage); dcMem.SelectObject(pOldBitmap); } CDialog::OnPaint();}이미지를 읽어와서 보정 후 그려주는 경우inline void SetBitmapAlpha(HDC hDC, HBITMAP hBmp){ BITMAP bm = { 0x00, }; GetObject(hBmp, sizeof(bm), &amp;bm); BITMAPINFO *pBi = (BITMAPINFO*)_malloca(sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))); if (pBi) { ::ZeroMemory(pBi, sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))); pBi-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER); BOOL bRes = ::GetDIBits(hDC, hBmp, 0, bm.bmHeight, NULL, pBi, DIB_RGB_COLORS); if (!bRes || pBi-&gt;bmiHeader.biBitCount != 32) return; LPBYTE pBitData = (LPBYTE) ::LocalAlloc(LPTR, bm.bmWidth * bm.bmHeight * sizeof(DWORD)); if (pBitData == NULL) return; LPBYTE pData = pBitData; ::GetDIBits(hDC, hBmp, 0, bm.bmHeight, pData, pBi, DIB_RGB_COLORS); for (int y = 0; y &lt; bm.bmHeight; y++) { for (int x = 0; x &lt; bm.bmWidth; x++) { pData[0] = (BYTE)((DWORD)pData[0] * pData[3] / 255); pData[1] = (BYTE)((DWORD)pData[1] * pData[3] / 255); pData[2] = (BYTE)((DWORD)pData[2] * pData[3] / 255); pData += 4; } } ::SetDIBits(hDC, hBmp, 0, bm.bmHeight, pBitData, pBi, DIB_RGB_COLORS); ::LocalFree(pBitData); }}void CMonosoftDlg::OnPaint(){ CClientDC dc(this); CDC dcMem; dcMem.CreateCompatibleDC(&amp;dc); int nX = 0; int nY = 0; CImage img; if(img.Load(_T(\"C:\\\\img.png\") == S_OK) { nX = img.GetWidth(); nY = img.GetHeight(); HDC hdc = img.GetDC(); SetBitmapAlpha(dcMem, img); BLENDFUNCTION bfImage = { AC_SRC_OVER, 0x00, 0xFF, AC_SRC_ALPHA }; AlphaBlend(dc.GetSafeHdc(), 100, 100, nX, nY, hdc, 0, 0,nX, nY, bfImage); img.ReleaseDC(); } CDialog::OnPaint();}" }, { "title": "우당탕탕 타우리 #008💬 프로세스 간 통신(IPC)", "url": "/posts/tauri_ipc/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows, IPC, event, command", "date": "2023-08-20 18:00:00 +0900", "snippet": "Contents 프로세스 간 통신(IPC; Inter-Process Communication) 이벤트(Event) 명령(Commands) 프로세스 간 통신(IPC; Inter-Process Communication)타우리에서는 프로세스 간 통신을 위해 서로 격리된 프로세스가 안전하게 보호된 통신을 할 수 있도록 Asynchronous Message Passing 이라는 독특한 스타일의 프로세스 간 통신을 사용합니다. 여기서 프로세스는 간단한 데이터 표현을 사용하여 직렬화된 요청 및 응답을 교환합니다. 메시지 전달은 수신자가 필요에 따라 요청을 거부하거나 폐기할 수 있기 때문에 공유 메모리 또는 직접 기능 액세스보다 안전한 기술입니다. 예를 들어 타우리 Core 프로세스가 요청을 악의적 메시지라고 판단하면 요청을 폐기 해버리고 해당 기능을 실행하지 않습니다. 이번 글에서 다룰 내용은 타우리가 사용하는 2가지의 프로세스간 통신 방법인 이벤트(event)와 명령(command)입니다. 이와는 별개로 IPC 호출을 가로채는 모킹(mocking)이라는 방법도 제공하고 있습니다. 모킹에 대해서는 향후에 따로 정리해 올리겠습니다.이벤트(Event)이벤트는 단방향으로만 메시지를 전송할 수 있으며, 하나의 프로세스에서 하나 이상의 프로세스로 이벤트를 보낼 수 있습니다. 전역 메시지의 경우 모든 프로세스에게 이벤트를 보낼 수 있으며, 지정한 프로세스에게만 이벤트를 보낼 수도 있습니다. 또한 이벤트는 아래에 소개할 명령(Commands)과는 달리 프론트엔드(Webview)와 코어 프로세스에서 모두 보낼 수가 있습니다.use tauri::{Window, AppHandle, Manager};use std::thread;#[tauri::command]fn call_rust(_window: Window, _app: AppHandle) { thread::spawn(move || { thread::sleep(std::time::Duration::from_secs(1)); _window.emit(\"emit_to_js\", \"Emit an event to the frontend.\").unwrap(); });}fn main() { tauri::Builder::default() .setup(|_app| { let main_window = _app.get_window(\"main\").unwrap(); let cc_main_window = main_window.clone(); let _ = cc_main_window.listen(\"emit_to_rust\", move |e| { println!(\"&gt;&gt; {}\", e.payload().unwrap()); }); ... Ok(()) }) .invoke_handler(tauri::generate_handler![call_rust]) .run(tauri::generate_context!()) .expect(\"error while running tauri application\");}const { invoke } = window.__TAURI__.tauri;const { listen } = window.__TAURI__.event;const { appWindow } = window.__TAURI__.window;...async function to_rust() { appWindow.emit('emit_to_rust', 'Emit an event to Rust.');};async function from_rust() { await listen('emit_to_js', e =&gt; { console.log(\"&lt;&lt; \" + e.payload); });} from_rust();window.addEventListener(\"DOMContentLoaded\", () =&gt; {...document .querySelector(\"#call-rust-button\") .addEventListener(\"click\", () =&gt; to_rust());});위의 예제는 javascript와 러스트에서 서로 이벤트를 발생시키는 예제입니다. 이벤트를 발생시키기 위해 각각 emit()을 이용하였습니다.요약단방향 메시지하나의 프로세스가 하나 이상의 프로세스에 이벤트를 보냄전역 또는 지정된 프로세스에 이벤트를 보내고 수신명령(Commands)명령은 프론트엔드(Webview)에서 Rust 함수 또는 메소드에 인수와 함께 직접 호출하고 결과 값을 반환 받을 수 있는 외부 함수 인터페이스입니다. async 키워드를 사용하여 비동기식으로 실행 할 수도 있습니다. 비동기식으로 실행할 경우에는 async_runtime::spawn을 이용하여 스레드에서 명령을 실행합니다. Rust 함수(또는 메소드)를 명령으로 바꾸려면, 함수(또는 메소드)위에 #[tauri::command] 한 줄을 추가하면 됩니다. 아래의 예를 참고하여 주세요.#[tauri::command]fn my_command(msg: String) { println!(\"I got message '{}'\", msg);}명령은 위의 예제에서 처럼 매개변수를 가질수도 있으며(없을 수도 있음), 매개변수로는 일반 매개변수와 특수 매개변수를 가질 수가 있습니다. 일반 매개변수는 사용자가 입력한 매개변수를 이야기 하며, 특수 매개변수는 tauri::command 매크로에 의해 자동으로 주입되는 tauri::window : 명령을 호출한 윈도우에 대한 핸들 tauri::AppHandle : 전연 인스턴스에 대한 핸들 tauri::State : 전역적으로 관리되는 상태 값 T를 입력(사용을 위해서 이전에 manage(T)를 호출해야 함) 위의 3 종류가 있습니다. 아래는 특수 매개변수에 대한 간단한 예시입니다.#[tauri::command]fn my_command(window: tauri::Window, _app: tauri::AppHandle, msg: String) { println!(\"I was invoked from window({}) and got message '{}'.\", window.label(), msg);}위의 두 예제에 대한 호출은 아래와 같이 호출 해주시면 됩니다.const { invoke } = window.__TAURI__.tauri;...await invoke(\"my_command\", {msg: \"Hello, Tauri!\"});두 함수의 정의는 각각 다른데, 위의 예제와 같이 하나로 호출이 가능한 것에 대해 의아해 하실 수 있습니다. 그 이유는 바로 tauri::command 매크로에 있습니다. 매크로는 프론트엔드(javascript)에서는 특수 매개변수는 보이지 않도록 재정의하기 때문입니다.이외에도 비동기식으로도 IPC 통신이 가능한데 이는 create-tauri-app을 이용하여 프로젝트를 생성하면 기본으로 생성되는 내용이기 때문에 설명을 생략하도록 하겠습니다. 요약Rust 함수 및 메소드 호출함수 및 메소드에 인수 전달호출된 함수 또는 메소드로부터 응답 수신async 키워드를 이용하여 비동기식으로 수행 가능 (async_runtime::spawn을 이용하여 별도의 스레드에서 명령을 수행) 참고 : 위의 내용은 타우리 공식 가이드문서의 『프론트엔드로 부터 러스트 호출하기』와 『이벤트』를 참고하여 만들었습니다." }, { "title": "우당탕탕 타우리 #007💬 Splash screen 만들기", "url": "/posts/tauri_splash_screen/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows, Splash, screen", "date": "2023-08-09 06:00:00 +0900", "snippet": "Contents Splash screen 웹 페이지를 이용한 방법 tauri.conf.json 설정 main.rs splash.js, splash.css 및 splash.html Rust 코드를 이용한 방법 main.rs Splash screen윈도우 어플리케이션에서는 Splash window라고도 불리는 Splash screen(이하 스플래쉬 스크린)을 만들어 보려고 합니다. 스플래쉬 스크린은 어플리케이션이 로딩되는 동안에 잠깐 나타났다가 사라지는 윈도우입니다. 따라서 로딩 시간이 긴 경우에는 스플래쉬 스크린을 통해 “지금 실행되고 있어요”라고 사용자가 인지할 수 있게 해주는 유용한 윈도우 입니다.웹 페이지를 이용한 방법tauri.conf.json 설정타우리 프로젝트를 만드시고 tauri.conf.json에 스플래쉬 스크린으로 사용할 윈도우를 아래와 같이 추가해 줍니다. \"windows\": [ { \"fullscreen\": false, \"resizable\": true, \"title\": \"SplashWindow\", \"width\": 800, \"height\": 600,+ \"visible\": false,+ \"center\": true+ },+ {+ \"fullscreen\": false,+ \"resizable\": false,+ \"width\": 250,+ \"height\": 250,+ \"visible\": true,+ \"center\": true,+ \"label\": \"splashscreen\",+ \"url\": \"splash.html\",+ \"alwaysOnTop\": true, + \"decorations\": false+ } ]’+’로 표기된 부분은 수정 또는 추가된 부분이며, 몇가지 중요한 부분을 집고 넘어 가겠습니다. 메인 윈도우의 경우에는 visible 값을 false로 변경하여 주시고, 새로 추가한 윈도우에 visible 값은 true를 입력합니다. 그리고 label에 적절한 값을 입력해줍니다. 이 label 속성은 향후 윈도우를 찾는데 사용될 것입니다. 그리고 url 속성의 값에는 로딩 페이지를 입력해줍니다. 마지막으로 decorations의 값을 false로 입력하여 윈도우의 타이틀바를 제거해줍니다.main.rs이제 main.rs의 소스를 열어,use tauri::{ Window, Manager };#[tauri::command]async fn close_splashscreen(window: Window) { if let Some(splashscreen) = window.get_window(\"splashscreen\") { std::thread::sleep(std::time::Duration::from_secs(2)); splashscreen.close().unwrap(); } window.get_window(\"main\").unwrap().show().unwrap(); }fn main() { tauri::Builder::default() .invoke_handler(tauri::generate_handler![close_splashscreen]) .run(tauri::generate_context!()) .expect(\"Failed to run app.\");}로딩이 완료되면 호출될 close_splashscreen 함수를 생성해줍니다. 함수 내의 내용을 살펴보면, splashscreen이라는 label 값을 갖는 윈도우인지 체크해서 splashscreen 윈도우라면 종료하도록 합니다. 그리고 프로젝트 생성시 자동으로 생성되었던 메인 윈도우를 보여지도록 합니다. main() 함수에는 이렇게 만들어진 close_splashscreen 함수를 자바스크립을 통해 접근할 수 있도록 invoke_handler 메소드를 이용하여 핸들을 등록시켜 줍니다.splash.js, splash.css 및 splash.html[ splash.js ]const { invoke } = window.__TAURI__.tauri;window.addEventListener(\"DOMContentLoaded\", () =&gt; { invoke('close_splashscreen');});[ splash.html ]&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;link rel=\"stylesheet\" href=\"splash.css\"&gt; &lt;title&gt;Splash window&lt;/title&gt; &lt;script type=\"module\" src=\"splash.js\" defer&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"loader\"&gt; &lt;div class=\"face\"&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"face\"&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;splash.css는 Comehope이 만드신 ‘Comet Rotating Loader’를 사용하였습니다. free 코드라고는 하는데 상용으로 사용하실때 한번 더 체크해보세요. splash.css는 아래의 링크를 참고해주세요.✏ codepen : Comet Rotating LoaderRust 코드를 이용한 방법tauri.conf.json, splash.js, splash.css, splash.html의 작업은 동일하고, main.rs의 소스코드만 아래와 같이 변경하시면 됩니다.main.rsuse tauri::{ Window, Manager };fn main() { tauri::Builder::default() .setup(|app| { let splash_window = app.get_window(\"splashscreen\").unwrap(); let main_window = app.get_window(\"main\").unwrap(); tauri::async_runtime::spawn(async move { println!(\"Initializing...\"); std::thread::sleep(std::time::Duration::from_secs(5)); println!(\"Done init...\"); splash_window.close().unwrap(); main_window.show().unwrap(); }); Ok(()) }) .run(tauri::generate_context!()) .expect(\"Failed to run app.\");}간단히 내용을 요약하자면, 스플래쉬 스크린과 메인 윈도우의 객체를 얻어오고 로딩 작업(tauri::async_runtime::spawn)이 끝나면 스플래쉬 스크린을 닫고(close()) 메인 윈도우를 보이게(show()) Rust 코드로도 구현이 가능합니다. 참고 : 위의 내용은 타우리 공식 가이드문서(https://tauri.app/v1/guides/features/splashscreen/)를 참고하여 만들었습니다." }, { "title": "코드사인 (CodeSign, EV CodeSign)", "url": "/posts/ev_codesign/", "categories": "정보, 유틸", "tags": "코드사인, CodeSign, EV-CodeSign", "date": "2023-06-02 06:00:00 +0900", "snippet": "Contents 코드사인 코드사인 인증서의 종류 코드사인을 위한 준비물 코드사인 하기 CodeSign EV CodeSign 코드사인개발된 프로그램을 온라인으로 배포할 경우 이 프로그램은 특정 회사에서 개발하여 안정성을 입증할 수 있다라는 것을 증명하기 위해 인증을 받는 디지털 서명 인증 방법입니다. 개발자가 유익한 프로그램을 만들 수 도 있고, 해킹 이나 바이러스를 만들 수 도 있으므로, 최종 사용자는 이것을 다운받아 실행하기 전에는 다운받아 사용해도 안전한지 알 수 없습니다. 그래서 코드사인을 하여, 다운받아 설치하게 될 프로그램이 어떤 회사에서 인증한 프로그램이다라는 것을 인지시켜주어 사용자가 안심하고 받을 수 있게 하는게 목적입니다. 온라인에서 다운받은 파일 실행시 “알 수 없는 게시자” 경고가 뜨는 경우는 코드사인이 되어 있지 않아 나타나는 메시지입니다.코드사인 인증서의 종류코드사인은 CodeSign과 EV CodeSign 두 종류의 인증서로 인증을 할 수 있습니다. 아래는 간단한 비교표입니다.   CodeSign EV CodeSign 암호화된 디지털 서명 ✔ ✔ 엄격한 심사 프로세스   ✔ 스마트 스크린 필터 경고창 즉시 해제   ✔ 보안토큰을 사용한 이중 인증   ✔ 코드사인을 위한 준비물코드 서명 작업을 위해서는 각 플랫폼에 해당하는 signing tool을 사용하여야 합니다. 코드 서명을 위한 준비물(공통) 서명툴 Microsoft 서명(signtool.exe) Microsoft SDK 다운로드 signtool.exe 설명 Java 서명(jarsigner) Java JDK 다운로드 Jarsigner 설명 코드서명 인증서 : .pfx 파일 또는 EV CodeSign 인증서가 설치된 USB Token USB Token Driver : EV CodeSign인 경우 인증서 제공업체의 별도 클라이언트 툴(예 : SafeNet Client Tool) 서명 대상 Application 코드사인 하기CodeSign Command창 입력 예시 [signtool_path]signtool.exe sign /f [pfx file] /p [password] /du “https://monoslab.github.io” /fd sha256 /tr http://timestamp.digicert.com [target_file] [signtool_path] : signtool.exe가 있는 폴더의 전체 경로 [pfx file] : 인증서(pfx) 파일이 있는 전체 경로(pfx 파일 포함) [password] : 비밀번호 (/p [password] 옵션을 사용하지 않을시 수동으로 비밀번호 입력 필요) [target_file] : 서명할 파일의 전체 경로(서명 파일 포함) InstallShield 설정 예시 설정 위치 : InstallShield &gt; Installation Designer &gt; PREPARE FOR RELEASE &gt; Releases &gt; Builds &gt; SingleImage &gt; Signing Digital Certificate Information 항목을 선택하고 아래의 항목을 선택 또는 입력합니다. ✔ Use a file (.pfx) &lt;ISProjectFolder&gt;\\prvkey\\monoslab.pfx pfx 파일의 전체 경로 입력, 예제에서의 설정은 인스톨쉴드 프로젝트 폴더내에 prvkey 폴더 아래에 pfx 파일이 있는 경우입니다. EV CodeSign Command창 입력 예시 [signtool_path]signtool.exe sign /a /s my /du “https://monoslab.github.io” /fd sha256 /tr http://timestamp.digicert.com [target_file] [signtool_path] : signtool.exe가 있는 폴더의 전체 경로 [target_file] : 서명할 파일의 전체 경로(서명 파일 포함) InstallShield 설정 예시 설정 위치 : InstallShield &gt; Installation Designer &gt; PREPARE FOR RELEASE &gt; Releases &gt; Builds &gt; SingleImage &gt; Signing Digital Certificate Information 항목을 선택하고 아래의 항목을 선택 또는 입력합니다. ✔ Use a certificate store Certificate Store Name : Personal Certificate Store Location : User Certificate Subject : MONOSLAB CO.,LTD " }, { "title": "우당탕탕 타우리 #006💬 INI 파일 가지고 놀기", "url": "/posts/tauri_ini/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows, INI", "date": "2023-05-22 06:00:00 +0900", "snippet": "Contents INI INI 파일 관리 ini 파일 생성(쓰기) ini 파일 읽기 INIINI 파일은 보통 프로그램의 실행에 필요한 설정과 관련한 정보를 저장하기 위한 목적으로 생성된 텍스트 문서를 말합니다.INI 파일 관리Cargo.toml 파일을 열어 ini 파일을 관리하기 위해 이미 충분히 검증된 rust-ini 크레이트를 아래와 같이 추가합니다.[dependencies]...rust-ini = \"0.19.0\"이제 main.rs의 소스를 열어,use std::io::stdout;use ini::Ini;const CONF_FILE_NAME: &amp;str = \"conf.ini\";fn main() { let mut conf = Ini::new(); conf.with_section(None::&lt;String&gt;).set(\"encoding\", \"utf-8\"); conf.with_section(Some(\"User\")) .set(\"name\", \"✔monoslab\") .set(\"value\", \"Pi\"); conf.with_section(Some(\"Library\")) .set(\"name\", \"홍길동\") .set(\"location\", \"대한민국\\x0a서울\"); conf.section_mut(Some(\"Library\")).unwrap().insert(\"seats\", \"100\"); println!(\"---------------------------------------\"); println!(\"Writing to file {:?}\\n\", CONF_FILE_NAME); conf.write_to(&amp;mut stdout()).unwrap(); conf.write_to_file(CONF_FILE_NAME).unwrap(); println!(\"----------------------------------------\"); println!(\"Reading from file {:?}\", CONF_FILE_NAME); let ini_file = Ini::load_from_file(CONF_FILE_NAME).unwrap(); println!(\"Iterating\"); let general_section_name = \"\"; for (sec, prop) in ini_file.iter() { let section_name = sec.as_ref().unwrap_or(&amp;general_section_name); println!(\"● Section: {:?} begins\", section_name); for (k, v) in prop.iter() { println!(\"{}: {:?}\", k, v); } } println!(); let section = ini_file.section(Some(\"User\")).unwrap(); println!(\"name={}\", section.get(\"name\").unwrap()); println!(\"conf[User][name]={}\", &amp;ini_file[\"User\"][\"name\"]); println!(\"General Section: {:?}\", ini_file.general_section());}아래는 위의 코드를 실행시켜 얻은 결과 값입니다.----------------------------------------Writing to file \"conf.ini\"encoding=utf-8[User]name=✔monoslabvalue=Pi[Library]name=홍길동location=대한민국\\n서울seats=100----------------------------------------Reading from file \"conf.ini\"Iterating● Section: \"_Default_\"encoding: \"utf-8\"● Section: \"User\"name: \"✔monoslab\"value: \"Pi\"● Section: \"Library\"name: \"홍길동\"location: \"대한민국\\n서울\"seats: \"100\"name=✔monoslabconf[User][name]=✔monoslabGeneral Section: Properties { data: {\"encoding\": \"utf-8\"} }ini 파일 생성(쓰기)위의 예제에 코드에서 주요 내용을 살펴보면,use std::io::stdout;use ini::Ini;먼저 파일을 읽고 쓰기 위해 러스트의 기본 패키지인 std::io::stdout을 사용하였고, ini 파일의 내용을 파싱하기 위해 ini::Ini를 사용하겠다고 정의하였습니다.let mut conf = Ini::new();conf.with_section(None::&lt;String&gt;).set(\"encoding\", \"utf-8\");...conf.section_mut(Some(\"Library\")).unwrap().insert(\"seats\", \"100\");conf.write_to(&amp;mut stdout()).unwrap();conf.write_to_file(CONF_FILE_NAME).unwrap();위의 코드는 뮤터블(mutable)한 Ini 객체를 생성하고, win_section 메소드로 섹션 설정 set 메소드를 이용하여 key와 value값을 설정합니다. 그리고 Ini 객체에 또 다른 섹션과 key, value 값을 설정하기 위해 section_mut 메소드로 섹션 추가 insert 메소드로 key, value 값을 추가합니다. write_to 메소드와 write_to_file 메소드는 각각 콘솔창과 파일로 ini 객체의 내용을 출력하는 방법입니다.ini 파일 읽기let ini_file = Ini::load_from_file(CONF_FILE_NAME).unwrap();...let section = ini_file.section(Some(\"User\")).unwrap();println!(\"name={}\", section.get(\"name\").unwrap());println!(\"conf[User][name]={}\", &amp;ini_file[\"User\"][\"name\"]);println!(\"General Section: {:?}\", ini_file.general_section());위의 코드는 load_from_file 메소드로 파일을 읽어와서 section 메소드를 이용하여 읽어 올 섹션을 정의하고 get 메소드에 key값을 넘겨주어 해당 key값의 데이터를 넘겨 받는 예 입니다. (ini_file.section(…).get(…)) 메소드를 이용하지 않고 &amp;ini_file[\"User\"][\"name\"]과 같이 바로 섹션명과 키값을 주어 value 값을 가져올 수도 있습니다. 마지막으로 general_section 메소드는 섹션이 설정되지 않은 항목을 json 포맷으로 읽어 옵니다." }, { "title": "🏆 C++의 왕좌를 이어받을 차세대 언어는?", "url": "/posts/cpp_prince/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, 차세대, 언어", "date": "2023-04-20 12:00:00 +0900", "snippet": "Contents 화려하게 한 세대를 풍미했던 C++의 왕좌를 이을 다음 언어는? 러스트 (Rust) 카본 (Carbon) Cpp프론트 (Cppfront) 화려하게 한 세대를 풍미했던 C++의 왕좌를 이을 다음 언어는?20여년 넘게 C++ 개발자로 살아오다보니, 다음에 C++의 자리를 차지할 언어에 대한 관심이 많습니다. 그래서 오늘은 C++ 왕좌를 이어받을 차세대 언어들에 대해 정리 해 보고자 합니다.아래의 3가지 차세대 언어가 그 후보들인데요. 아직까지는 먼저 세상에 나온 러스트가 다른 언어에 비해 우위를 차지하고 있습니다. 하지만 구글의 힘(Go와 Dart 언어의 성공적인 개발 노하우)을 업은 카본과 정통 C++에 현대적인 언어의 장점을 점진적으로 추가하여 진화하고 있는 Cpp프론트도 그 영향력을 무시할 수 없을 것으로 판단이 됩니다. 러스트 (Rust) 개발 : 러스트 재단 (Graydon Hoare; 그레이든 호아레) 목표 : C/C++와 동등한 수준의 속도를 달성하면서 안전성, 동시성을 목표로 함. 깃허브 : https://github.com/rust-lang 버전 : Rust 1.68.2 (2023.04.20 현재) 카본 (Carbon) 개발 : 구글 목표 : C++을 대체하거나 기존 레거시 C++코드와의 상호 운용성 달성을 목표로 함. 깃허브 : https://github.com/carbon-language 버전 : 2024년(또는 2025년) 1.0 출시 예상 Cpp프론트 (Cppfront) 개발 : ISO C++ (Herb Sutter; 허브 셔터) 목표 : C++의 10배 더 간단하고, 안전하며, 도구를 사용하기 쉽게 구현하는 것을 목표로 함. 깃허브 : https://github.com/hsutter 버전 : 미정 러스트 (Rust)✔러스트는 기존 자료를 참고해주세요.카본 (Carbon)구글에서 C++ 생태계 위에 구축을 하고 있는 카본은 C++과 유사하게 설계하고 있습니다. 성능을 중요시하는 소프트웨어. 실용적이고 안전한 메커니즘. 최신 플랫폼, 하드웨어 아키텍처 환경을 고려. 완만한 학습 곡선. 비슷한 표현식. 기존 C++ 코드와의 원활한 상호 운용성 및 마이그레이션.아직까지는 컴파일러(또는 툴체인)가 없고 인터프리터를 사용해서 맛보기만 가능합니다. 맛보기Cpp프론트 (Cppfront)C++은 1985년 발표된 이래 최근의 C++20 버전까지 매우 오랫동안 전세계적으로 많이 사랑받고 있는 언어입니다. 20여년 전까지만 해도 프로그래밍의 기초를 다지기 위해 C/C++ 언어를 배웠었습니다. 이제는 어쩌면 그 역활을 Cpp프론트가 대신할지도 모르겠네요. 기존 C++과 완전히 호환되는 새로운 구문(syntax)으로 간결하고 안전하게 코딩. 메모리 안전을 기본으로 지원. C++20 모듈과 C++23 import std를 기본으로 탑재. 현대화된 언어로 탈바꿈. (아래의 예제 참조)main: () -&gt; int = { vec: std::vector&lt;std::string&gt; = (\"hello\", \"cppfront\"); view: std::span = vec; for view do :(inout str: _) = { len := decorate(str); println(str, len); } }" }, { "title": "우당탕탕 타우리 #005💬 JSON 파일 가지고 놀기", "url": "/posts/tauri_json/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows, JSON", "date": "2023-04-12 12:00:00 +0900", "snippet": "Contents JSON JSON 파일 읽기 JSON 파일 저장하기 JSONJSON은 JavaScript 객체 리터럴, 배열, 스칼라 데이터를 표현하는 텍스트 기반의 파일이며, 프로그램에서 파싱 및 생성하기가 쉽기 때문에 많은 곳에서 사용되고 있습니다.JSON 파일 읽기타우리의 프로젝트 폴더인 src-tauri 아래에 conf 폴더를 하나 생성하고, 그 폴더에 conf.json 파일을 생성하고 아래의 예시처럼 데이터를 입력하고 저장합니다. (폴더 위치는 자신이 선호하는 위치에 하시면 됩니다. 여기서는 설명을 위한 예시로 conf 폴더를 생성한 것 뿐입니다.){\t\"url\": \"https://monoslab.github.io/\",\t\"port\": 443,\t\"debug\": false}위의 conf.json 파일을 읽어 오기 위해 tauri.conf.json 파일에 리소스를 추가해 줍니다. 배열에 각각의 파일을 입력하여도 되지만 *를 이용하여 conf 폴더내의 모든 파일을 추가하도록 하겠습니다. 그리고 타우리의 모든 API를 사용하도록 허용 해주겠습니다.{ \"build\": { ... }, \"package\": { ... }, \"tauri\": { \"allowlist\": { \"all\" : true }, \"bundle\": { ... \"resources\": [ \"conf/*\" ] } }} 다음으로 Cargo.toml 파일을 열어[dependencies]...serde_json = \"1.0\"를 추가해 줍니다.이제 main.rs의 소스를 열어,use std::env;use std::fs::File; fn main() { let resource_path = format!(\"{}\\\\conf\\\\conf.json\", parent_path()); let file = File::open(&amp;resource_path).unwrap(); let conf:serde_json::Value = serde_json::from_reader(file).unwrap(); println!(\"URL : {}\", conf.get(\"url\").unwrap()); println!(\"PORT : {}\", conf.get(\"port\").unwrap()); println!(\"DEBUG : {}\", conf.get(\"debug\").unwrap());}fn parent_path() -&gt; String { let path = env::current_exe().unwrap(); format!(\"{}\", path.parent().unwrap().display())}위와 같이 코딩 해주고 실행시켜 보면 아래와 같은 결과값을 얻으실 수 있습니다.URL : \"https://monoslab.github.io/\"PORT : 443DEBUG : falseJSON 파일 저장하기아래의 코드는 읽어 왔던 JSON 파일 변경하여 저장하는 예제입니다.use std::env;use std::fs;use std::str::FromStr;use serde_json::{Number, Value};fn main() { let resource_path = format!(\"{}\\\\conf\\\\conf.json\", parent_path()); let file = fs::File::open(&amp;resource_path).unwrap(); let mut conf:Value = serde_json::from_reader(file).unwrap(); // 읽기 println!(\"URL : {}\", conf.get(\"url\").unwrap()); println!(\"PORT : {}\", conf.get(\"port\").unwrap()); println!(\"DEBUG : {}\", conf.get(\"debug\").unwrap()); // json 데이터 변경 후 쓰기 conf[\"url\"] = Value::String(String::from(\"http://monoslab\")); conf[\"port\"] = Value::Number(Number::from_str(\"80\").unwrap()); conf[\"debug\"] = Value::Bool(false); _ = fs::write(resource_path, serde_json::to_string_pretty(&amp;conf).unwrap());}fn parent_path() -&gt; String { let path = env::current_exe().unwrap(); format!(\"{}\", path.parent().unwrap().display())}serde_json::Value를 이용하여 json의 자료형으로 변환 후 각각의 키에 값을 넣어주고 파일시스템(fs) API를 통해 파일을 저장하면 됩니다. 빌드 후 conf.json 파일을 열어보면 아래와 같이 우리가 원하는 결과 값으로 저장이 되어 있을 것입니다.{\t\"debug\": false,\t\"port\": 80,\t\"url\": \"http://monoslab\"}" }, { "title": "우당탕탕 타우리 #004💬 프로젝트의 설정 파일들", "url": "/posts/tauri_json_toml/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows, Setting", "date": "2023-04-12 06:00:00 +0900", "snippet": "Contents 프로젝트 설정 cargo.toml tauri.conf.json 프로젝트 설정오늘은 프로젝트의 설정 파일들(tauri.conf.json, cargo.toml)에 대해 알아 보겠습니다.cargo.toml이 매니페스트 파일은 프로젝트에서 어떤 Rust Crate에 의존하는지 정의하며, 앱에 대한 부가 정보를 설정할 수 있습니다. 크게 package, build-dependencies, dependencies, features로 구분이 되고, 라인의 첫 글자가 #으로 시작하면 주석으로 간주합니다.[package]name = \"Monoslab\"version = \"0.0.1\"description = \"Premium application\"authors = [\"monoslab&lt;my@mail.com&gt;\"]license = \"MIT\"keywords = [\"cargo\", \"toml\", \"monoslab\"]repository = \"https://github.com/rust-lang/cargo/\"edition = \"2021\"[build-dependencies]tauri-build = { version = \"1.2\", features = [] }[dependencies]tauri = { version = \"1.2\", features = [\"api-all\", \"icon-png\", \"system-tray\"] }serde = { version = \"1.0\", features = [\"derive\"] }serde_json = \"1.0\"[features]# this feature is used for production builds or when `devPath` points to the filesystem# DO NOT REMOVE!!custom-protocol = [\"tauri/custom-protocol\"]위에서 부터 하나씩 살펴 보면, [package]에는 프로젝트의 일반적인 정보들이 들어가 있습니다. 각각의 항목에 대한 내용은 아래와 같습니다. name : 프로젝트 이름 version : 프로그램의 버전 description : 프로젝트에 대한 간략한 설명 keyword : crates.io에 라이브러리를 등록했을 때 다른 사용자들이 키워드로 쉽게 검색할 수 있도록 여기에 키워드를 설정합니다. 키워드는 최대 5개까지 가능하며, 키워드의 시작은 문자, 숫자 또는 _로 시작하여야 하며 최대 20자까지 가능합니다. authors : 프로그램 저작자들의 리스트. (반드시 저작자 이름과 메일주소가 형식에 맞게 작성되어야 합니다.) license : 저작권 종류를 표시 (MIT, BSD, GPL, LGPL 등) repository : 패키지 소스의 레파지토리 URL 입력(입력하지 않아도 상관없음) edition : 패키지가 컴파일되는 Rust 에디션에 영향을 미치는 선택적 값입니다. (예시 처럼 2021이면 Cargo.toml 버전과의 호환성을 2021버전으로 간주합니다.)[build-dependencies]는 빌드 스크립트의 빌드에 필요한 creates들의 이름과 버전을 등록합니다. [dependencies]는 프로젝트가 사용하는 crates들의 이름과 버전이 등록합니다. 여기에 crate를 등록해야지만 프로젝트에서 사용할 수 있습니다. 필요한 create은 https://crates.io 에서 찾을 수 있습니다. 참고 : dependencies에 version에 =이 붙는 경우 항상 동일한 버전(정확한 버전)의 의존성 create가 다운로드 됩니다. 그렇지 않은 경우(=이 붙지 않는 경우)에는 1.2버전의 가장 최신 버전이 1.2.0.10일 경우 1.2.0.10 버전으로 다운로드가 이루어 집니다. 예) version = “=1.2”tauri.conf.json이 JSON 파일은 앱의 다양한 맞춤 설정을 할 수 있도록 돕습니다.{ \"build\": { \"beforeDevCommand\": \"npm run build\", \"beforeBuildCommand\": \"npm run dev\", \"devPath\": \"../src\", \"distDir\": \"../src\", \"withGlobalTauri\": true }, \"package\": { \"productName\": \"Monoslab\", \"version\": \"0.0.1\" }, \"tauri\": { \"allowlist\": { \"all\": true }, \"window\": { \"all\": true } }, \"bundle\": { \"active\": true, \"icon\": [ \"icons/32x32.png\", \"icons/128x128.png\", \"icons/128x128@2x.png\", \"icons/icon.icns\", \"icons/icon.ico\" ], \"identifier\": \"com.monoslab.test\", \"copyright\": \"Copyright (c) Monoslab 2023. All rights reserved.\" \"targets\": \"all\" } }}tauri.conf.json은 아래의 3가지 오브젝트로 구성되어 있습니다. build : 타우리를 빌드시 필요한 경로 또는 명령어를 추가 할 수 있습니다. package : 앱의 이름과 버전 정보를 입력합니다. tauri : 프로젝트에서 사용할 API의 허용 범위를 지정하며, 리소스, 번들, 보안, 업데이트, 윈도우 설정 등을 지정할 수 있습니다. 참고 : 공홈에서는 plugins를 포함하여 4개로 정의하고 있는데, 어디에서도 샘플을 찾을 수가 없어서 향후 해당 정보를 알게 되면 내용을 수정하도록 하겠습니다.tauri.conf.json의 설정은 너무 자료가 방대하여 자세한 설명은 여기를 참조하기 바랍니다. 여기에서는 많이 사용하는 것 위주로 한해 대략적으로 설명하도록 하겠습니다. build의 beforeBuildCommand는 tauri build를 돌릴 때 이 명령어를 실행하도록 설정합니다. 마찬가지로 beforeDevCommand는 tauri dev를 돌릴 때 이 명령어가 실행됩니다. package의 productName에는 앱의 이름을 지정할 수 있으며, version에는 앱의 버전을 지정합니다. tauri는 앱에서 사용할 허용 목록을 설정하고 어디까지 사용할지에 대한 권한을 부여합니다. “allowlist”의 “all”의 값이 true인 경우 타우리의 모든 API에 대한 사용을 모두 허용한다는 뜻입니다. 만약 all이 false인 경우 허용할 목록을 직접 작성하야 합니다. 아래는 간단한 예입니다.\"allowlist\": { \"all\": false, \"fs\": { \"all\": true, }, ...모든 타우리 API에 대해 사용을 허용 하지 않았기 때문에 사용을 하고자 하는 API의 허용 목록을 따로 작성을 하여야 합니다. 위의 예시에서는 타우리에서 제공하는 모든 API 중에서 오직 파일 시스템(fs) API에 관련된 것만 모두 사용하겠다는 의미입니다.“bundle”의 경우 앱의 식별 정보와 리소스 등을 지정할 때 사용합니다." }, { "title": "우당탕탕 타우리 #003💬 프로젝트의 폴더 및 파일 구성", "url": "/posts/tauri_fold_and_file/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows", "date": "2023-03-23 06:00:00 +0900", "snippet": "Contents Tauri 구성 폴더/파일 구성 Tauri 구성프로젝트의 설정(tauri.conf.json, cargo.toml)에 대해 알아보기 전에 폴더와 파일 구성을 먼저 알고 가는 것이 좋을 듯 하여 강좌 순서를 조금 바꾸어봤습니다. 먼저 폴더 및 파일의 기본 구성을 알아 보고 다음 강좌에서 설정 파일에 대해 알아보도록 하겠습니다.폴더/파일 구성create-tauri-app 도구를 이용하여 프로젝트를 생성하면 기본적으로 아래의 구성으로 프로젝트가 생성되게 됩니다...\\Tauri_Project| package.json| README.md|+---src| | index.html| | main.js| | styles.css| || \\---assets| javascript.svg| tauri.svg|\\---src-tauri | build.rs | Cargo.lock | Cargo.toml | tauri.conf.json | +---icons | 128x128.png | 128x128@2x.png | 32x32.png | icon.icns | icon.ico | icon.png | Square107x107Logo.png | Square142x142Logo.png | Square150x150Logo.png | Square284x284Logo.png | Square30x30Logo.png | Square310x310Logo.png | Square44x44Logo.png | Square71x71Logo.png | Square89x89Logo.png | StoreLogo.png | +---src | main.rs | \\---target폴더들에 대해 먼저 알아보겠습니다. src : Front-end 소스들이 위치하게 됩니다. 웹과 관련된 소스 및 리소스를 포함하는 폴더입니다. src/assets : 웹에서 사용할 에셋들을 저장할 수 있는 폴더입니다. src-tauri : Back-end 소스들이 위치하게 됩니다. rust와 관련된 설정, 소스, 리소스등을 포함하는 폴더입니다. src-tauri/icons : 각 OS에 아이콘들을 포함하고 있는 폴더입니다. 여기에 이미지들은 각 앱의 아이콘으로 사용이 됩니다. src-tauri/src : 러스트의 소스 파일이 있는 폴더입니다. src-tauri/target : 빌드시 debug/release 바이너리 파일이 생성되는 폴더입니다.주요 파일들에 대해 살펴보면, 루트 package.json : 프로젝트에 필요한 패키지에 대한 정보를 담고 있습니다. src 폴더 index.html : tauri에서 가장 먼저 호출하는 page입니다. main.js : 여기에 html에서 사용할 javascript를 작성합니다. styles.css : html에서 사용할 스타일을 정의합니다. src-tauri 폴더 build.rs : 프로젝트에 필요한 소스 파일을 컴파일하고 패키지를 빌드하기 직전에 실행합니다. (C라이브러리 구축, 호스트 시스템에서 C라이브러리 찾기, Rust 모듈 생성하기, 크레이트에 필요한 플랫폼 구성등의 작업 수행) 작업예시 cargo.lock : 프로젝트에 필요한 의존하고 있는 크레이트의 정확한 버전을 트랙킹하기 위한 파일입니다. (수정 금지) cargo.toml : cargo로 만든 프로젝트의 설정 파일이며 패키지에 관한 정보 및 크레이트들을 관리합니다. tauri.conf.json : tauri의 정보 및 권한 등을 설정할 수 있는 파일입니다. src-tauri/src 폴더 main.rs : 프로그램의 시작점이 되는 main 함수가 있는 파일입니다." }, { "title": "[ Project ] Workboard 설계 및 개발", "url": "/posts/cef3-workboard/", "categories": "프로젝트", "tags": "프로젝트, CEF3, 워크보드, Workboard", "date": "2023-03-20 06:00:00 +0900", "snippet": "Contents Workboard 설계 Workboard UI Workboard 주요 기능 Workboard 설계회사에서 웹 서비스를 하나의 브라우저에 함께 보여주는 프로젝트를 진행하게 되었고, 방대한 웹 소스를 병합하여 처리하는 것보다 브라우저에서 웹 서비스간 연계 작업을 진행하는 것이 비용면에서 절감할 수 있을 것으로 판단되어 워크보드를 개발하게 되었습니다. 워크보드에는 톡, 그룹웨어, 메뉴를 3단 구성하고 이들간에 데이터 연동을 할 수 있도록 개발하고 있습니다.Workboard UI Workboard는 Chromium Embedded Framework의 기술을 이용합니다. 좌측부터 톡(채팅), 그룹웨어, 메뉴 순으로 구성이 됩니다. 톡(채팅)의 경우는 고정이며, 그룹웨어의 경우는 때에 따라서 기간계 시스템으로 대체될 수 있습니다. 메뉴는 서버의 설정된 메뉴로 유동적으로 구성이 가능하며, 톡과 그룹웨어(또는 기간계 시스템)에 명령을 전달하거나 특정 액션을 취할 수 있습니다. (예 : 프로그램 실행, 자동화 작업 등) Workboard 주요 기능 Javascript Event 처리 알림창(대화, 쪽지, 메일, 기타 기간계 시스템 알림 등) 표시 및 링크 웹 캐시 삭제 단축키 지원 원격제어 화면캡쳐 파일 업/다운로드 로컬의 특정 프로그램 실행 Workboard 업데이트" }, { "title": "우당탕탕 타우리 ####💬 타이틀바 커스트마이징", "url": "/posts/tauri_custm_titlebar/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, Windows", "date": "2023-03-10 06:00:00 +0900", "snippet": "Contents 타이틀바 커스트마이징 tauri.conf.json index.html main.js 타이틀바 커스트마이징tauri.conf.json타이틀바를 커스트마이징 하기 위해서는 타우리 설정 파일에서 윈도우에 관련된 몇가지 항목을 설정해줘야 합니다. 아래는 tauri.conf.json의 내용중 타이틀바 커스트마이징시 필요한 내용중 일부분입니다.\"tauri\": { \"allowList\": { ... \"window\": { \"all\": false, \"close\": true, \"hide\": true, \"show\": true, \"maximize\": true, \"minimize\": true, \"unmaximize\": true, \"unminimize\": true, \"startDragging\": true } } ... \"windows\": [ { ... \"decorations\": false } ]}먼저 tauri &gt; windows 항목에 decorations 키를 false로 설정합니다. decorations 옵션이 적용되면 타이틀바가 사라지게되고, 드래그를 할 수 있는 영역이 사라져서 드래그를 할 수 없는 상태가 됩니다. 다음으로 tauri &gt; allowList &gt; window 항목에서 타이틀바가 없을 경우 필요한 시스템 메뉴의 key/value를 설정합니다. 여기서 startDragging은 반드시 사용함(true)로 설정해주셔야 생성할 타이틀바 영역을 드래그하여 윈도우를 이동시킬 수 있으니 유의해야합니다. 그 외의 시스템 버튼들은 필요에 따라 사용함(true)으로 설정해주시면 됩니다.index.htmltauri.conf.json 설정이 완료되면 프로젝트 폴더의 src/index.html 파일을 아래와 같이 수정해줍니다.// titlebar.css.titlebar { height: 30px; background: #0077ff; user-select: none; display: flex; justify-content: flex-end; position: fixed; top: 0; left: 0; right: 0; } .titlebar-button { display: inline-flex; justify-content: center; align-items: center; width: 30px; height: 30px; } .titlebar-button:hover { background: #bed3f8; }&lt;html&gt; &lt;head&gt;... &lt;link rel=\"stylesheet\" href=\"titlebar.css\" /&gt;... &lt;/head&gt; &lt;body&gt;... &lt;div data-tauri-drag-region class=\"titlebar\"&gt; &lt;div class=\"titlebar-button\" id=\"titlebar-minimize\"&gt; &lt;img src=\"https://api.iconify.design/mdi:window-minimize.svg\" alt=\"minimize\" /&gt; &lt;/div&gt; &lt;div class=\"titlebar-button\" id=\"titlebar-maximize\"&gt; &lt;img src=\"https://api.iconify.design/mdi:window-maximize.svg\" alt=\"maximize\" /&gt; &lt;/div&gt; &lt;div class=\"titlebar-button\" id=\"titlebar-close\"&gt; &lt;img src=\"https://api.iconify.design/mdi:close.svg\" alt=\"close\" /&gt; &lt;/div&gt; &lt;/div&gt;... &lt;/body&gt;&lt;/html&gt;위와 같이 잘 적용되었다면, 빌드 후 정상적으로 타이틀바가 나타나고 드래그 및 우리가 원했던 시스템 버튼들이 보여지게 될 것입니다. 마지막으로 보여지는 버튼들에게 살아 숨쉴수 있도록 숨을 불어 넣어 주어야겠죠.main.jssrc/main.js 파일을 아래와 같이 수정해줍니다.const { invoke } = window.__TAURI__.tauri;...window.addEventListener(\"DOMContentLoaded\", () =&gt; { ... 중략 ... document .querySelector('#titlebar-minimize') .addEventListener('click', () =&gt; window.__TAURI__.window.appWindow.minimize()); document .querySelector('#titlebar-maximize') .addEventListener('click', () =&gt; window.__TAURI__.window.appWindow.toggleMaximize()); document .querySelector('#titlebar-close') .addEventListener('click', () =&gt; window.__TAURI__.window.appWindow.close());});이제 모든 작업이 완료되었습니다. 버튼들을 눌러보면 모두 정상적으로 작동 됨을 확인하실 수 있을 것입니다." }, { "title": "[ Error ] Rust Error/Warning 해결 방법", "url": "/posts/err-rust-solved/", "categories": "정보, 에러, 경고", "tags": "Error, Warning, solved", "date": "2023-03-09 06:00:00 +0900", "snippet": "Contents A snake case nameA snake case name warning: crate xxx should have a snake case name 해결방법 : Cargo.toml 파일에서 name을 스네이크 케이스(소문자 + ‘_’ 조합)로 변경하거나, main.rs의 상단 부분에 #![allow(non_snake_case)] 한 줄을 추가하면 해결이 됩니다." }, { "title": "우당탕탕 타우리 #002💬 프로젝트 생성하기", "url": "/posts/create_tauri_app/", "categories": "프로그래밍, RUST", "tags": "RUST, WebView, Tauri", "date": "2023-03-03 06:00:00 +0900", "snippet": "Contents ✔ create-tauri-app 도구로 Tauri 프로젝트 생성하기 ⛓ PowerShell 이용하기 ⛓ Cargo 이용하기 ✔ create-tauri-app 도구로 Tauri 프로젝트 생성하기Tauri는 거의 모든 프론트엔드 스택과 호환이 됩니다. 프로젝트를 생성하기 가장 쉬운 방법은 create-tauri-app을 이용하는 것입니다. 이 도구는 vanilla HTML/CSS/JavaScript나 React, Svelte, Yew 등의 다양한 프론트엔드 프레임워크를 위한 독자적인 템플릿을 제공합니다.여기서는 윈도우에는 기본적으로 설치되어 있는 PowerShell과 개발을 위해 설치해야하는 Cargo를 이용하는 방법으로 진행을 해보도록 하겠습니다. 이외의 다양한 방법은 tauri 공홈 문서(https://tauri.app/v1/guides/getting-started/setup/)에서 확인하시기 바랍니다. 아래의 2가지 방법중 하나를 이용해서 기본 골격의 tauri 프로젝트를 생성합니다.⛓ PowerShell 이용하기파워쉘을 오픈하고 프로젝트 폴더를 생성할 폴더로 이동 후 아래의 명령을 입력합니다. PS C:\\&gt;$env:CTA_ARGS=”–alpha”;iwr -useb https://create.tauri.app/ps | iex info: downloading create-tauri-app ✔ Project name · Workboard ✔ Choose which language to use for your frontend · Rust - (cargo) ✔ Choose your UI template · Vanilla ✔ Would you like to setup the project for mobile as well? · no Please follow https://tauri.app/v1/guides/getting-started/prerequisites to install the needed prerequisites, if you haven’t already. You also need to install tauri-cli (cargo install tauri-cli –version 2.0.0-alpha.2) Done, now run: cd Workboard cargo tauri dev위에 프로젝트 생성시 프론트엔드를 Rust로 선택하였으며, Choose which language to use for your frontend · Rust - (cargo)Rust로 선택하는 경우에는 패키지를 관리하기 위한 패키지 매니저를 선택할 수 없습니다. 아래에 다시 설명을 하겠지만, 프론트엔드를 예시처럼 TypeScript / JavaScript를 선택한 경우에는 패키지 매니저를 선택하여야 합니다. Rust를 선택한 경우에 src-tauri 폴더 아래의 Cargo.toml을 살펴 보면, 아래와 같이 라이브러리 항목이 생성된 것을 확인 하실수 있습니다. [lib] name = “Workboard_lib” crate-type = [“staticlib”, “cdylib”, “rlib”]프론트엔드로 Rust를 설정하였기에 라이브러리를 생성해주어야 오류가 발생되지 않습니다. 일단 우리는 기본 화면을 띄울 것이기 때문에 이 부분을 주석(#) 처리 해줍니다. #[lib] #name = “Workboard_lib” #crate-type = [“staticlib”, “cdylib”, “rlib”]작업이 모두 끝났다면, 아래와 같이 cargo run 명령을 입력합니다. PS C:\\Workboard\\src-tauri&gt; cargo run오류가 발생하지 않았다면 아래와 같이 브라우저가 정상적으로 출력이 될 것입니다.⛓ Cargo 이용하기우선 윈도우 Command 창을 열고 프로젝트를 생성할 폴더로 이동 후 아래의 명령을 입력하여 create-tauri-app을 설치합니다. C:\\&gt; cargo install create-tauri-app Updating crates.io index Downloaded create-tauri-app v3.0.2 Downloaded 1 crate (254.6 KB) in 1.27s Installing create-tauri-app v3.0.2 Downloaded libflate v1.3.0 Downloaded libflate_lz77 v1.2.0 Downloaded dialoguer v0.10.3 Downloaded syn v1.0.109 Downloaded shell-words v1.1.0 Downloaded tempfile v3.4.0 Downloaded console v0.15.5 Downloaded 7 crates (389.6 KB) in 1.10s Compiling typenum v1.16.0 … 중략 … Compiling create-tauri-app v3.0.2 Finished release [optimized] target(s) in 1m 51s Replacing C:\\Users\\mono.cargo\\bin\\cargo-create-tauri-app.exe Replaced package create-tauri-app v2.7.6 with create-tauri-app v3.0.2 (executable cargo-create-tauri-app.exe)위의 설치 과정이 끝났다면 cargo를 이용하여 create-tauri-app을 실행합니다. C:\\&gt; cargo create-tauri-app ✔ Project name · Workboard2 ✔ Choose which language to use for your frontend · TypeScript / JavaScript - (pnpm, yarn, npm) ✔ Choose your package manager · pnpm ✔ Choose your UI template · Vanilla ✔ Choose your UI flavor · JavaScript Please follow https://tauri.app/v1/guides/getting-started/prerequisites to install the needed prerequisites, if you haven’t already. Done, now run: cd Workboard2 pnpm install pnpm tauri dev프로젝트 생성시 프론트엔드를 TypeScript / JavaScript로 선택한 예시입니다. Choose which language to use for your frontend · TypeScript / JavaScript - (pnpm, yarn, npm)이 경우에는 패키지를 관리해줄 패키지 매니저를 지정해줘야 합니다. 필자는 이미 PC에 설치되어 있는 pnpm을 선택하여 지정해줬습니다.위와 마찬가지로 작업이 모두 끝났다면, 아래와 같이 cargo run 명령을 이용하여 앱을 실행시킬 수도 있고, 패키지 매니저인 pnpm을 이용하여 앱을 실행할 수도 있습니다. C:\\Workboard2\\src-tauri&gt; cargo runpnpm은 cargo create-tauri-app 명령 수행후 아래의 실행 방법 예시처럼 C:\\&gt; cd Workboard2 C:\\Workboard2&gt; pnpm install C:\\Workboard2&gt; pnpm tauri dev명령을 차례대로 입력하시면 완성된 브라우저가 뜨게 될 것입니다.다음 강좌에서는 프로젝트의 설정(tauri.conf.json, cargo.toml)에 대해 알아보는 시간을 갖도록 하겠습니다. ※ 참고pnpm 설치 및 버전 업데이트 방법pnpm 버전 확인 : pnpm -vnpm 이용 : npm install -g pnpm윈도우 파워쉘 이용 : iwr https://get.pnpm.io/install.ps1 -useb | iex" }, { "title": "우당탕탕 타우리 #001💬 What is 타우리", "url": "/posts/tarui_info/", "categories": "프로그래밍, RUST", "tags": "RUST, WebView, Tauri", "date": "2023-02-21 06:00:00 +0900", "snippet": "Contents 타우리(Tauri)란? NOT 라이선스 아키텍쳐 타우리 도구 기본 도구 추가 도구 그 외 타우리(Tauri)란?타우리는 Rust 와 HTML을 이용하여 Webview를 통해 데스크탑용 애플리케이션을 구축하는데 사용되는 툴킷입니다. 데스크탑에 설치되어 있는 OS의 기본 Webview를 이용하기 때문에 배포파일의 크기가 다른 웹앱(크로미엄, 일렉트론 등)에 비해 매우 작으며, OS에서 Webview를 관리하기 때문에 별도로 업데이트 및 유지 관리가 필요하지 않습니다. 또한 Rust에 의해 컴파일되어 별도의 런타임을 제공하지 않아도 독립적으로 실행이 가능합니다.NOT VM이나 가상화 환경이 아니다. Webview OS 애플리케이션을 만들기 위한 어플리케이션 툴킷입니다. 단순한 커널 랩퍼(Wrapper)가 아니다. 직접적으로 OS에 대한 시스템 호출을 위해 WRY와 TAO를 이용합니다.라이선스 MIT 또는 Apache-2.0 라이선스 적용.아키텍쳐 타우리는 런타임, 매크로, 유틸리티 및 API를 포함하는 툴킷으로 컴파일시에 tauri.conf.json 파일에서 필요한 기능들을 확인하고 앱 생성시에 기능들을 추가하게 됩니다. tauri-runtime 하위 수준의 webview 라이브러리와 타우리 사이의 런타임 라이브러리입니다. tauri-macros Tauri-codegen 크레이트를 활용하여 컨텍스트, 핸들러 및 명령을 위한 매크로를 만듭니다. tauri-utils 환경 파일 구문 분석, 플랫폼 트리플(Platform triples) 감지, CSP(Content Security Policy) 와 Assets 관리 등과 같은 많은 곳에서 재사용이 가능한 유용한 유틸리티를 제공하는 공통 코드입니다. tauri-runtime-wry 이 라이브러리는 인쇄, 모니터 감지와 윈도우 관련 작업과 같은 WRY를 위한 시스템 수준의 특별한 상호작용을 할 수 있게 합니다. tauri-build cargo에 필요한 어떤 특수 기능을 조작하기 위해 빌드시 매크로를 적용합니다. tauri-codegen 앱과 시스템 트레이를 위한 아이콘을 포함하여 Assets을 삽입, 해시 및 압축한다. 컴파일시 tauri.con.json을 분석하고 Config 구조체를 생성합니다. 업스트림(Upstream) 라이브러리 WRY Cross-platform Webview rendering library : Windows, macOS, Linux와 같은 모든 주요 데스크탑 플랫폼을 지원하는 크로스 플랫폼용 Webview 렌더링 Rust 라이브러리이며 플랫폼에 맞는 웹뷰를 선택하고 상호작용을 결정해주는추상화 계층입니다. Webview와의 인터페이스를 유지하고 관리합니다. TAO Cross-platform application window creation library : Windows, MacOS, Linux와 같은 모든 주요 플랫폼을 지원하는 크로스 플랫폼용 창 생성 Rust 라이브러리이며 애플리케이션 윈도우를 만들고 관리합니다. (Rust로 작성되었으며 메뉴 표시줄 및 시스템 트레이 등과 같은 것을 구현할 수 있습니다.) 타우리 도구기본 도구 API (JavaScript / TypeScript) Webview가 백엔드 활동을 위해 호출/수신 하도록 프론트엔드 프레임워크에 임포트하기 위해 CommonJS(cjs)와 ECMAScript Module(esm) JavaScript 엔드포인트(요청을 받아 응답을 제공하는 서비스를 사용할 수 있는 지점)를 생성하는 TypeScript 라이브러리 입니다. 호스트에 웹뷰의 메시지 전달을 위해 사용합니다. Bundler (Rust / Shell) MacOS, Windows 및 Linux 등의 플랫폼용 타우리 앱을 빌드하기 위한 라이브러리입니다. (참고로 현재 모바일 플랫폼을 위한 알파 버전이 나와 있습니다.) cli.rs (Rust) 이 Rust 실행 파일은 MacOS, Windows 및 Linux의 CLI가 필요로 하는 요구 활동에 대한 모든 인터페이스를 제공합니다. cli.js (JavaScript) 각 플랫폼의 npm 패키지를 생성하기 위해 napi-rs를 사용하여 cli.rs를 래핑한 래퍼입니다. create-tauri-app (JavaScript) 선택한 프론트엔드 프레임워크의 새 프로젝트를 신속하게 구축할 수 있도록 해주는 툴킷입니다.추가 도구 tauri-action 어떠한 설정도 없이 모든 플랫폼(MacOS, Linux 및 Windows)을 위한 아주 기본적인 타우리 앱을 생성할 수 있습니다. 만약 프로젝트에 Tauri 파일이 포함되어 있지 않으면 컴파일시에 파일을 생성합니다. tauri-vscode 이 프로젝트는 몇 가지 유용한 기능으로 Visual Studio Code 인터페이스를 향상시킵니다. vue-cli-plugin-tauri vue-cli 프로젝트에 Tauri를 매우 빠르게 설치할 수 있습니다.그 외 Awesome Tauri : 타우리에서 사용할 수 있는 유용한 플러그인들이 있는 github. 링크 본문 내용 출처 : https://tauri.app/v1/references/architecture/ 각주 업스트림(Upstream) : 클라이언트나 로컬기기(일반적으로 컴퓨터나 모바일기기)에서 서버나 원격 호스트(서버)로 전송되는 데이터 또는 보내는 것을 의미합니다. ↩" }, { "title": "워크보드(웹앱)", "url": "/posts/naonsoft-010/", "categories": "", "tags": "", "date": "2023-02-20 09:00:00 +0900", "snippet": "워크보드(타우리 툴킷을 이용한 웹앱) 기간 : 2023.02 ~ 2023.08■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : Rust, C++ 타우리 툴킷을 이용하여 멀티 플랫폼에서 구동 가능한 브라우저입니다. (모바일 버전은 지원하지 않음)기본적으로 웹 클라이언트와 타우리 간의 통신과 이벤트 처리(알림 등)를 지원합니다." }, { "title": "멀티 브라우저 (Chromium 기반)", "url": "/posts/naonsoft-009/", "categories": "", "tags": "", "date": "2023-02-01 09:00:00 +0900", "snippet": "멀티 브라우저 (Chromium 기반) 기간 : 2023.02 ~ 2023.06■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ 웹 메신저와 그룹웨어를 한 화면에서 함께 처리하기 위한 멀티 브라우저입니다. 두 개의 웹 클라이언트 간의 통신과 이벤트 처리(알림 등)를 할 수 있습니다." }, { "title": "[ VC++ ] CEF3와 WebView2 비교", "url": "/posts/cef3_vs_webview2/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, CEF3, WebView2, Chromium, Edge, Windows", "date": "2023-01-18 06:00:00 +0900", "snippet": "Contents CEF3와 WebView2 비교 통신 방법 Javascript Injection 및 실행 유지 보수적인 측면 결론CEF3와 WebView2 비교CEF3와 WebView2는 모두 Chromium 기반이지만 두 프레임워크는 약간의 차이를 보이고 있습니다.통신 방법 CEF3 “Javascript binding”을 통한 애플리케이션과 통신. MessageRouters를 이용하여 cefQuery로 통신. OnWebKitInitialized에서 javascript 함수(window.chrome.webview.postMessage() 함수 생성)를 구현하여 통신. WebView2 “Javascript binding” 후 호출로 애플리케이션과의 통신을 위한 방법은 제시되어 있으나, 현재까지는 문제가 있어 사용하지 않는것 같음. window.chrome.webview.postMessage()로 애플리케이션 통신.(JSON, 문자열 등) Javascript Injection 및 실행CEF3와 WebView2 모두 가능합니다.유지 보수적인 측면 CEF3 장점 : 윈도우에 설치된 크롬 엔진과는 별개로 엔진을 운용함.웹과 통신하기 위한 인터페이스를 자유롭게 만들 수 있음. 단점 : Chromium 엔진 업데이트시 많은 비용이 소요됨. 배포파일 용량이 큼.(120Mb 이상) WebView2 장점 : Nuget을 이용하여 엔진 업데이트시 적은 비용으로 처리가 가능.MS Edge를 렌더링 엔진으로 사용하기 때문에 배포파일의 용량이 적음. 단점 : 정형화된 통신 방법으로만 통신이 가능 함. (인터페이스를 자유롭게 만들 수 있는지는 확인이 필요.)윈도우에 설치된 Edge를 렌더링 엔진으로 사용하고 있어 영향을 받음.Edge 업데이트 유무에 따라 기능의 차이 발생 가능. 결론커스트마이징이 많이 필요한 경우에는 WebView2를 이용하기 보다는 CEF3를 이용하는 것이 자유도 측면에서는 훨씬 유리한 것으로 판단이 됩니다. 모든 것이 그렇듯 상황에 따라 장/단점을 따져 적절하게 프로젝트에 이용하는 것이 답입니다." }, { "title": "우당탕탕 타우리 #000💬 Tauri와 Electron 비교", "url": "/posts/tauri_vs_electron/", "categories": "프로그래밍, RUST", "tags": "RUST, Tauri, 타우리, Electron, 일렉트론, Windows", "date": "2023-01-13 06:00:00 +0900", "snippet": "Contents Tauri vs Electron 두 프레임워크의 주요 장/단점 비교 결론Tauri vs ElectronTauri와 Electron은 모두 웹 기술을 기반으로 크로스 플랫폼을 지원하고 있으며, Desktop Application을 구축하기 위한 훌륭한 프레임워크입니다. HTML, CSS 및 Javascript를 이용하여 Windows, MacOS, Linux에서 실행할 수 있는 애플리케이션을 구축할 수 있습니다. 하지만 이 두 프레임워크에는 아래와 같은 차이점이 존재합니다. Tauri는 프론트엔드는 거의 모든 프론트엔드 프레임워크와 호환이 되고, 백엔드에서는 Rust 기반 엔진을 사용하고 CLI(Command line interface)은 Node.js를 사용합니다. 추후에는 백엔드로 Rust뿐만 아니라 Python, C++, Deno도 지원할 예정이라고 하니 점점 더 각광받는 프레임워크가 될 것 같습니다. Electron는 Node.js를 기반으로 Chromium엔진을 사용하여 사용자 인터페이스를 렌더링하고 기본 API에 대한 액세스를 제공하여 데스크탑 애플리케이션 구축에 대한 전통적인 접근 방식을 제공하고 있습니다. 이를 통해 애플리케이션을 빠르고 쉽게 구축할 수는 있지만 Tauri 애플리케이션보다 느리고 안전하지 못한 단점이 있습니다. 아직 두 프레임워크 모두 모바일은 지원하고 있지 않으나, Tauri의 경우는 모바일 빌더를 지원하겠다고 언급하였기 때문에 조만간 그 실체를 볼 수 있을 것 같습니다.두 프레임워크의 주요 장/단점 비교 Tauri는 Rust 엔진을 이용하여 각 플랫폼의 WebView를 사용합니다. 이때문에 Tauri 애플리케이션은 기존의 웹 기반 애플리케이션보다 더 작고 빠르며 보안적으로 더 안전합니다. Electron은 Chromium 엔진을 이용하여 사용자 인터페이스를 렌더링하고 시스템의 기본 API에 대한 액세스를 제공합니다. 이를 통해 Electron은 웹개발 기술을 토대로 애플리케이션을 빠르고 쉽게 구축할 수 있습니다. Tauri는 Rust를 이용하여 웹에서 시스템의 네이티브 API와 기능을 이용할 수 있는 플러그인을 개발할 수 있으며, 기존의 웹앱이 가진것보다 더 강력하고 유연하게 개발을 할 수 있습니다. Electron은 C/C++을 이용하여 웹에서 시스템의 네티이브 API와 기능을 이용할 수 있는 플러그인을 개발할 수 있으나 기본 플러그인을 구축하는 것은 웹 기반 기술을 사용하는 것보다 더 어렵습니다. Tauri는 다양한 플랫폼을 지원하는 내장 빌드 시스템으로 외부 도구나 서비스 없이도 사용자에게 배포할 설치 프로그램을 손쉽게 만들 수 있습니다. Electron도 다양한 플랫폼용 설치 프로그램을 만드는 데 사용할 수 있는 내장 빌드 시스템을 제공하지만, Tauri에서 제공하는 것만큼 유연하지 않으며 외부 도구나 서비스를 사용해야 할 수도 있습니다. Tauri는 2019년 12월 Pre-Alpha로 처음 출시되었고 2022년 6월에 정식 버전이 출시되었습니다. 이렇다 보니 커뮤니티가 적으며, 국내에선 잘 알려지지 않은 편입니다. Electron은 2013년 Atom의 프레임워크로 시작하여 역사가 길고 많은 사람이 사용하다 보니 커뮤니티 및 오픈소스가 많습니다. Tauri는 설치 프로그램 용량이 3Mb 이상으로 크기가 적습니다. Electron은 설치 프로그램 용량이 최소 120Mb 이상으로 큽니다. 또한 시스템 리소스 사용율이 Tauri 보다 높습니다. Tauri는 Rust 언어를 사용하여 애플리케이션을 만들기 때문에 보안적으로 안정적입니다. Electron은 Node.js 기반의 애플리케이션이다 보니 보안에 취약합니다. 웹앱 소스의 노출이 쉽기 때문에 이를 통한 공격이 용이하며, 보안에 더 각별히 신경을 써야합니다. Tauri는 백엔드 작업을 위해서는 Rust라는 언어에 대한 이해도가 있어야 하며, 이로 인해 높은 진입 장벽이 있습니다. 하지만 앞서 언급했듯이 Python, C++, Deno도 지원할 예정이어서 향후에는 진입 장벽이 낮아질 수 있을것 같습니다. Electron은 웹 개발자가 새로운 언어를 익힐 필요없이 데스크탑 프로그램을 만들 수 있고, 진입 장벽이 낮으며, 그만큼 개발 속도가 빠른 장점을 가집니다.간단하게 두 프레임워크의 장/단점을 윈도우 기준으로 요약하자면…   Tauri Electron 실행파일 크기 3Mb 이상 120Mb 이상 메모리 사용량 80Mb 이상 120Mb 이상 AppBackend Rust Node.js 런타임 랜더링 윈도우 : WebView2(Edge)리눅스 : WebKitGTKMacOS : WebKit 윈도우 : Chromium리눅스 : ChromiumMacOS : Chromium 보안 안전 앱 소스 코드를 쉽게 탈취할 수 있어 보안에 매우 취약 업데이트 내장 Updater 사용(업데이트 서버 운영 필요) electron-updater 패키지 사용(GitHub 릴리즈에서 직접 바이너리를 업데이트) 커뮤니티 국내 : 없음해외 : 적음 커뮤니티와 오픈소스가 많음 결론Tauri와 Electron 모두 웹 기술을 이용하여 크로스 플랫폼 애플리케이션을 구축하기에 좋은 프레임워크입니다. 하지만 Tauri는 Electron 보다 더 나은 보안성과 다양한 프레임워크들과의 호환성 및 배포 파일 용량과 리소스 점유율 등 다방면에서 좋은 면모를 보여주고 있습니다. 다만 현재까지의 Tauri의 가장 큰 걸림돌은 Rust언어에 대한 이해도가 있어야 한다는 점입니다. 지금까지의 내용을 근거로 가까운 미래에는 Electron을 Tauri가 밀어내고 더 좋은 위치에 있지 않을까 조심스레 점쳐봅니다." }, { "title": "[ Flutter ] Flutter와 Electron 비교", "url": "/posts/flutter_vs_electron/", "categories": "프로그래밍, Flutter", "tags": "Flutter 3.0, 플러터 3.0, Electron, 일렉트론, Windows", "date": "2022-12-16 06:00:00 +0900", "snippet": "Contents Flutter vs Electron 두 프레임워크의 주요 장/단점 비교 구동하는 언어와 기술 진입 장벽 개발 속도 크로스 플랫폼 지원 Native API 지원 Third-Party 지원 웹어셈블리(Wasm) DevTools(디버깅 툴) 지원 Third-Party 지원 종속성 Isolate(격리) 빌드 툴 및 인스톨러 제공 성능 결론 Flutter Electron Flutter vs Electron두 프레임워크의 주요 장/단점 비교데스크탑 애플리케이션 개발시 두 프레임워크의 장/단점은 아래의 표와 같습니다.   Flutter Electron 장점 모바일 개발을 위한 훌륭한 솔루션 데스크탑에서 웹 애플리케이션을 개발하기 위한 훌륭한 솔루션 단점 데스크탑용 위젯과 자료는 아직까지는 미흡함 어플리케이션의 실행 파일이 큼많은 메모리/리소스를 사용함경우에 따라서는 긴 시작 시간과 버벅임이 발생. 구동하는 언어와 기술 Flutter 언어 : Dart, C/C++ 등 기술 Null에 대한 안전한 지원. C 라이브러리를 이용하여 이식성을 높임. Dart VM을 통한 JIT(Just-in-time; 개발 모드에서만 사용)과 네이티브 앱을 위한 AOT(ahead-of-time) 컴파일러 지원. 컴파일러를 통해 기계어 코드를 생성. Electron 언어 : Javascript, HTML 등 기술 자바스크립트 V8 엔진 사용. 노드JS(Node.js)를 기반으로 자바스크립트·HTML·CSS를 사용. V8은 JIT(Just -In-Time Compilation )로 JavaScript를 내부적으로 컴파일 하여 실행 속도를 높임. 진입 장벽 Flutter : 높음 Dart 언어를 배워야하며, 플러그인을 개발하기 위해서는 C/C++언어를 배울 필요가 있음. Electron : 낮음 자바스크립트를 이용한 웹 개발자가 데스크탑 애플리케이션을 만들기 위해 새로운 기술이나 언어를 배울 필요가 없음. 개발 속도 Flutter : 빠름 다양한 플러그인을 활용하여 빠르게 개발을 할 수 있음. Electron : 빠름 인터프리터 방식을 사용하는 자바스크립트를 이용하기 때문에 디버깅이 쉽고 애플리케이션을 빠르게 구현할 수 있음. 일반적으로 웹 애플리케이션의 디자인, 비즈니스 로직등을 재사용할 수 있기 때문에 개발 시간이 줄어듦. 크로스 플랫폼 지원 Flutter : 지원 각 OS별 네이티브 API 이용시 기능 제약이나 별도의 버전을 가져가야할 수도 있음. Electron : 부분 지원 각 OS별 기능 제약이나 별도의 버전을 유지할 필요 없이 하나의 애플리케이션으로 개발 가능. (모바일용은 지원하지 않음) Native API 지원 Flutter : 지원 데스크탑의 시스템 자원 활용시 지원되지 않는 것은 plugin 개발을 통해 지원 가능. Electron : 지원 각 OS별 런타임을 제공해서 시스템의 자원을 손쉽게 활용 가능함. Third-Party 지원 Flutter : 지원 pub.dev 사이트를 통해 패키지를 제공하고 있으며 각 패키지들의 샘플 소스가 잘되어 있어 활용하기 용이함. 패키지에 원하는 기능이 “올인원”인 경우는 드물어서 다수개의 패키지를 설치하여 사용. 패키지의 기능 수정을 위해서는 C/C++을 알아야 하며, plugin 개발 방법도 함께 숙지하여야 함. 간단한 프로그램을 만들더라도 다수개의 패키지를 설치/관리하여야 하는 상황이 발생함. Electron : 지원 Node JS의 빌트인 모듈과 써드파티 모듈의 이용 가능. Node JS를 통해 파일시스템에 접근하고 네트워크 리소스도 제약없이 이용. NPM에 등록된 대부분의 모듈도 이용 가능. 웹어셈블리(Wasm)브라우저를 염두에 두고 특별히 설계된 기계 코드를 위한 새로운 이진 형식입니다. WebAssembly1로 컴파일된 앱은 성능 저하 없이 JavaScript와 함께 실행할 수 있습니다. Flutter : 지원 Electron : 지원DevTools(디버깅 툴) 지원 Flutter : 지원 Electron : 지원Third-Party 지원 Flutter : 안전 데스크톱의 경우 컴파일러를 통해 애플리케이션을 생성하여 안전함. 모바일의 경우 보안 및 인증 플러그인을 제공. Electron : 취약 자바스크립트를 통해 파일 시스템 및 사용자 쉘 등에 접근이 가능하기 때문에 보안에는 취약할 수 있으며, 이에 대한 대책이 필요함. 종속성 Flutter : 낮음 불필요한 코드와 종속성 제거 작업이 원활함. Electron : 높음 좀 더 복잡한 작업을 위해서는 Angular, React 또는 Vue와 같은 타사 JavaScript 프레임워크를 활용해야 함.(이러한 프로임워크에도 종속성이 있어서 webpack을 구성하여 모든 종속성을 번들로 묶어주어야 함) Isolate(격리) Flutter : 지원 Dart에서 각 스레드의 자체 메모리로 격리되어 있음. 서로 다른 격리간 통신은 포트를 통한 값을 전달하는 방식. Electron : 지원 작업자 스레드를 사용하여 JavaScript를 병렬로 실행. 빌드 툴 및 인스톨러 제공 Flutter : 일부 제공 빌드 툴은 제공하나 인스톨러는 제공하지 않음. Electron : 제공 데스크톱 애플리케이션을 손쉽게 패키징 가능. 또한 autoUpdater라는 구성 요소를 이용하면 애플리케이션 자동 업데이트 기능도 사용할 수 있음. 각 플랫폼 빌드시 해당 플랫폼에서만 컴파일 가능. 성능 Flutter 실행 속도 : 빠름 실행 파일 크기 : 38Mb 이상 리소스(CPU, GPU) 및 메모리 사용 : 낮음 Electron 실행 속도 : 느림 실행 파일 크기 : 100Mb 이상 리소스(CPU, GPU) 및 메모리 사용 : 높음 결론Flutter아직까지 Flutter의 Desktop은 걸음마 단계이며, 조금 더 시간이 흐른 후 다시 검증이 되어야 할 것입니다. 현재까지의 검증 결과로 보면 Flutter는 메모리 공간과 설치 크기가 더 작습니다. 이러한 수치는 특히 Dart가 계속해서 최적화됨에 따라 개선될 가능성이 있습니다. 필요한 최소한의 개발자 구성으로 여러 플랫폼을 쉽게 타겟팅할 수 있습니다. Flutter의 플랫폼 통합 및 FFI(Foreign Function Interface)2는 환상적인 솔루션입니다. Dart의 null에 대한 안전성과 Wasm의 잠재적 통합은 Flutter를 더 낫은 프레임워크로 만들어 갈 것입니다.ElectronElectron은 배포 파일의 크기와 메모리 사용량이 큽니다. 또한 배포 파일 생성시 포함하는 모듈, 로드되는 시기 및 애플리케이션 패키징 방법에 대해 더 주의를 기울여야 합니다. Flutter와 마찬가지로 Wasm 통합은 특정 작업에서의 성능을 크게 향상시킬 수 있습니다.위의 내용을 참고하여 내가 하고자 하는 프로젝트에 어떠한 것이 더 적합할지 선택하여야합니다. 데스크탑용 프로그램을 개발하고자 할 경우 두 프레임워크 모두 좋은 도구가 될 것입니다. 🙂위에서 언급했듯이 Flutter 데스크탑 지원은 아직까지는 안정적이지 않습니다. MacOS의 경우 iOS와 유사하여 현재로서는 MacOS 데스크탑에서는 최고의 경험을 제공하지만 Windows와 Linux도 그리 뒤지지는 않습니다. 그리고 아직까지는 Electron의 일부 기본 기능(알림, 작업 표시줄 아이콘 등)은 데스크탑용 Flutter에서는 사용할 수 없습니다. 하지만 곧 Flutter에서도 이용이 가능하게 될 것입니다. WebAssembly는 최신 웹 브라우저에서 실행할 수 있는 새로운 유형의 코드입니다. 기본 성능에 가깝게 실행되고 C/C++, C# 및 Rust와 같은 언어를 제공하는 압축 바이너리 형식의 저수준 어셈블리 유사 언어입니다. 웹에서 실행할 수 있도록 컴파일 대상이 있습니다. 또한 JavaScript와 함께 실행되도록 설계되어 둘 다 함께 작동할 수 있습니다. WebAssembly JavaScript API를 사용하여 WebAssembly 모듈을 JavaScript 앱에 로드하고 둘 사이에서 기능을 공유할 수 있습니다. 이를 통해 WebAssembly 코드를 작성하는 방법을 모르더라도 동일한 앱에서 WebAssembly의 성능과 기능, JavaScript의 표현력과 유연성을 활용할 수 있습니다. &#8617; 한 프로그래밍 언어에서 다른 프로그래밍 언어의 함수를 호출하기 위한 인터페이스를 말합니다. C언어는 역사가 오래 되었을 뿐만 아니라 그 동안 축적된 코드베이스(code base)가 풍부하므로 많은 언어들이 C언어로 작성한 코드를 사용하기 위한 FFI를 가지고 있습니다. &#8617; " }, { "title": "[ Flutter ] 플러터를 이용한 윈도우용 앱 개발 (2)", "url": "/posts/flutter_dev_basic/", "categories": "프로그래밍, Flutter", "tags": "Flutter 3.0, 플러터 3.0, Windows", "date": "2022-12-09 06:00:00 +0900", "snippet": "Contents Windows용 Flutter 프로젝트 생성 프로젝트 불러오기 브라우저 만들기 패키지 설치 개발하면서 느낀점Windows용 Flutter 프로젝트 생성&gt; mkdir Sample &gt; cd Sample &gt; flutter create --template=app --platforms=windows nfbrowser Creating project nfbrowser... Running \"flutter pub get\" in nfbrowser... 1,506ms Wrote 27 files. All done! 프로젝트 불러오기 Android studio 실행 생성된 프로젝트 불러 오기 ** 상단 메뉴 &gt; File &gt; Open을 차례로 눌러 조금전에 생성한 디렉토리로 이동하여 프로젝트를 오픈합니다. ** shift + F10 또는 메뉴의 run &gt; Run ‘main.dart’ 를 클릭하여 컴파일 후 정상적으로 윈도우가 뜨는지 확인합니다.브라우저1 만들기패키지 설치pubspect.yaml 파일의 프로젝트에서 사용할 dependencies에 패키지를 추가합니다.dev_dependencies: webview_windows: ^0.2.2 system_tray: ^2.0.2 window_manager: ^0.2.8 easy_localization: ^3.0.0 window_size: git: url: https://github.com/google/flutter-desktop-embedding.git path: plugins/window_size ref: 5c51870ced62a00e809ba4b81a846a052d241c9f순서대로 webview_windows 패키지는 웹브라우저를 개발하기 위한 패키지입니다. system_tray는 윈도우의 시스템 트레이 영역에 아이콘을 표시를 위해 사용합니다. window_manager는 시스템 종료 버튼에 다른 액션을 주기 위해 사용하였습니다.(종료 버튼 클릭시 숨김 처리) easy_localization은 다국어를 위한 패키지입니다. window_size는 아직 공홈에서 지원하는 패키지가 아니어서 git에서 직접 받아와서 사용하였습니다. 윈도우의 타이틀 및 사이즈 변경을 위하여 사용하였습니다.차례대로 main.dart 파일에 모두 import 시켜줍니다.import 'package:webview_windows/webview_windows.dart';import 'package:system_tray/system_tray.dart';import 'package:window_manager/window_manager.dart';import 'package:easy_localization/easy_localization.dart';import 'package:nfbrowser/model/nfbrowser.dart';import 'package:window_size/window_size.dart'; webview_windows : 웹브라우저 위젯 system_tray : 시스템 트레이 위젯 window_manager : 윈도우 종료 관련 처리를 위한 위젯 easy_localization : 다국어 처리를 위한 위젯 window_size : 윈도우 타이틀, 사이즈 변경을 위한 위젯메인에서 다국어 처리를 하고 MyApp 위젯을 호출합니다.void main() async { // easylocalization 초기화 await EasyLocalization.ensureInitialized(); runApp(EasyLocalization( supportedLocales: [ const Locale('en', 'US'), const Locale('ko', 'KR')], path: 'assets/lang', // 언어 파일 경로 fallbackLocale: const Locale('en', 'US'), // fallbackLocale supportedLocales에 설정한 언어가 없는 경우 설정되는 언어 child: const MyApp()));}class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( debugShowCheckedModeBanner: false, // 디버그 표시를 없앰. navigatorKey: NfBrowser.naviagatorState, // 기본적으로 필요한 언어 설정 localizationsDelegates: context.localizationDelegates, supportedLocales: context.supportedLocales, locale: context.locale, home: const NfBrowser()); }}MyApp 위젯에서 앱의 상단의 디버그 표시를 없애고 홈으로 NfBrowser()를 설정해 줍니다.class NfBrowser extends StatefulWidget { const NfBrowser({Key? key}) : super(key: key); static final GlobalKey&lt;NavigatorState&gt; naviagatorState = GlobalKey&lt;NavigatorState&gt;(); @override _NfBrowserState createState() =&gt; _NfBrowserState();}class _NfBrowserState extends State&lt;NfBrowser&gt; with WindowListener { final _appWindow = AppWindow(); final _systemTray = SystemTray(); final _menuMain = Menu(); final _webview = WebviewController(); final _textEdit = TextEditingController(); final _isWindows = Platform.isWindows; late NFBrowser nfbrowser; @override Widget build(BuildContext context) { return MaterialApp( debugShowCheckedModeBanner: false, // 디버그 표시를 없앰. navigatorKey: navigatorKey, home: Scaffold( body: Center( child: compositeView(), ), ), ); } Widget compositeView() { if (!_webview.value.isInitialized) { return const Text( 'Not Initialized', style: TextStyle( fontFamily: '맑은 고딕', fontSize: 24.0, fontWeight: FontWeight.w700, //.w900, ), ); } else { return Container( // padding: EdgeInsets.all(10), padding: EdgeInsets.zero, child: Column( children: [ Expanded( child: Card( color: Colors.transparent, elevation: 0, clipBehavior: Clip.antiAliasWithSaveLayer, shape: RoundedRectangleBorder( borderRadius: const BorderRadius.only( // if you need this topLeft: Radius.circular(25), topRight: Radius.circular(25), ), side: BorderSide( color: Colors.grey.withOpacity(0.2), width: 1, ), ), child: Stack( children: [ Webview( _webview, permissionRequested: (url, permissionKind, isUserInitiated) =&gt; WebviewPermissionDecision.allow, ), StreamBuilder&lt;LoadingState&gt;( stream: _webview.loadingState, builder: (context, snapshot) { if (snapshot.hasData &amp;&amp; snapshot.data == LoadingState.loading) { return const LinearProgressIndicator(); } else { return Container(); } } ), ], ) ) ), ], ), ); } } @override void initState() { windowManager.addListener(this); super.initState(); loadInit(); } void loadInit() async { await loadData(); await init(); await initSystemTray(); await initPlatformState(); if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) { setWindowTitle('appname'.tr()); setWindowMaxSize(Size.infinite); } } @override void dispose() { windowManager.removeListener(this); super.dispose(); } @override void onWindowEvent(String eventName) { print('[WindowManager] onWindowEvent: $eventName'); } @override void onWindowClose() async { // do something bool isPreventClose = await windowManager.isPreventClose(); if (isPreventClose) { _appWindow.hide(); } } @override void onWindowFocus() { // Make sure to call once. setState(() {}); // do something } Future&lt;bool&gt; loadData() async { String data = await rootBundle.loadString(\"assets/NFBrowser.json\"); final jsonResponse = json.decode(data); nfbrowser = NFBrowser.fromJson(jsonResponse); debugPrint('= [JSON] =============================================='); debugPrint(jsonResponse.toString()); debugPrint('======================================================='); setState(() {}); return true; } Future&lt;void&gt; init() async { // Add this line to override the default close handler await windowManager.setPreventClose(true); setState(() {}); } Future&lt;void&gt; initSystemTray() async { List&lt;String&gt; iconList = ['open', 'exit']; // We first init the systray menu and then add the menu entries await _systemTray.initSystemTray(iconPath: getTrayImagePath('app_icon')); _systemTray.setTitle('appname'.tr()); _systemTray.setToolTip('appver'.tr(namedArgs: {'name': 'appname'.tr(), 'ver': 'Ver. 1.0.1'})); _systemTray.setContextMenu(_menuMain); // handle system tray event _systemTray.registerSystemTrayEventHandler((eventName) { debugPrint(\"eventName : $eventName\"); if(eventName == kSystemTrayEventClick) { _isWindows ? _appWindow.show() : _systemTray.popUpContextMenu(); } else if (eventName == kSystemTrayEventRightClick) { _isWindows ? _systemTray.popUpContextMenu() : _appWindow.show(); } }); await _menuMain.buildFrom( [ MenuItemLabel(label: 'open'.tr(), image: getImagePath('open'), onClicked: (menuItem) { debugPrint(\"Open Menu\"); _appWindow.show(); } ), MenuSeparator(), MenuItemLabel(label: 'exit'.tr(), image: getImagePath('exit'), onClicked: (menuItem) { debugPrint(\"Exit Menu\"); //_appWindow.close(); windowManager.destroy(); } ), ] ); } Future&lt;void&gt; initPlatformState() async { var adminauto = nfbrowser.adminauto; var protocol = nfbrowser.protocol; var domain = nfbrowser.domain; debugPrint('&gt;&gt; adminauto : ${adminauto.toString()}'); debugPrint('&gt;&gt; protocol : ${protocol.toString()}'); debugPrint('&gt;&gt; domain : $domain'); try { await _webview.initialize(); _webview.url.listen((url) { _textEdit.text = url; }); late String url; if(protocol == 1) { url = 'https://$domain'; } else { url = 'http://$domain'; } await _webview.setBackgroundColor(Colors.transparent); await _webview.setPopupWindowPolicy(WebviewPopupWindowPolicy.allow); await _webview.loadUrl(url); if (!mounted) return; setState(() {}); _appWindow.show(); } on PlatformException catch(e) { debugPrint(e.toString()); } } Future&lt;WebviewPermissionDecision&gt; _onPermissionRequested( String url, WebviewPermissionKind kind, bool isUserInitiated) async { final decision = await showDialog&lt;WebviewPermissionDecision&gt;( context: navigatorKey.currentContext!, builder: (BuildContext context) =&gt; AlertDialog( title: const Text('WebView permission requested'), content: Text('WebView has requested permission \\'$kind\\''), actions: &lt;Widget&gt;[ TextButton( onPressed: () =&gt; Navigator.pop(context, WebviewPermissionDecision.deny), child: const Text('Deny'), ), TextButton( onPressed: () =&gt; Navigator.pop(context, WebviewPermissionDecision.allow), child: const Text('Allow'), ), ], ), ); return decision ?? WebviewPermissionDecision.none; // 왼쪽 표현식 값이 null이 아니면 왼쪽 값을 null이면 오른쪽 값을 리턴한다. }}개발하면서 느낀점 패키지 패키지에 원하는 기능이 “올인원”인 경우는 드물어서 다수개의 패키지를 설치하여 사용하여야 합니다. 패키지의 기능 수정을 위해서는 C/C++을 알아야 하며, plugin 개발 방법도 함께 숙지하여야 합니다. 간단한 프로그램을 만들더라도 다수개의 패키지를 설치/관리하여야 하는 상황이 발생합니다. 디바이스 지원 패키지가 모바일/데스크탑 모두 지원하는 경우도 있지만 그렇지 않은 경우도 있기 때문에 최악의 경우 모바일/윈도우/맥OS/리눅스의 패키지를 찾아서 따로 설치하여야 하는 경우 발생할 수도 있습니다.(이 경우는 디바이스에 의존적인 자원을 사용하는 경우 각 시스템별 사용법이 달라서 패키지 개발을 따로 특정 디바이스에 맞춰 개발한 경우에 발생함) 윈도우의 경우 아직 지원이 많이 부족하여, plugin을 만들어 사용해야하는 경우가 발생할 수 있습니다. (plugin의 기술력이 요구됨) DPI awareness 윈도우의 멀티모니터 지원시 각각의 배율을 설정하여 사용하는데, 이를 해지할 수 있는 패키지가 없습니다. DPI 관련해서는 플루터 엔진에서 설정된 내용을 가져올 수만 있고 셋팅하는 부분은 따로 존재하지 않습니다. Plugin 개발 Windows에서 Flutter 플러그인을 개발하려면 주로 C++ 및 MFC API를 사용하여 Flutter 코덱을 통해 네이티브 플러그인과 Flutter 간에 통신합니다. 또 다른 방법은 FFI를 사용하여 Dart에서 많은 win32 API를 캡슐화하고 Dart를 직접 사용하여 win32 앱을 작성 하는 Dart 패키지 win32 와 같이 Dart가 FFI 를 통해 Windows API를 호출 하도록 하는 것입니다. 브라우저 : 윈도우의 WebView2를 이용한 브라우저. &#8617; " }, { "title": "[ RUST ] 러스트", "url": "/posts/rust/", "categories": "프로그래밍, RUST", "tags": "RUST, 러스트", "date": "2022-12-02 06:00:00 +0900", "snippet": "Contents 러스트(RUST) 란? 러스트 장/단점(개인적 견해) 러스트에서 공식적으로 발표한 잇점 러스트 개발 환경 러스트 설치 Cargo를 이용한 프로젝트 생성 및 관리러스트(RUST) 란?러스트는 2006년 모질라의 개발자 그레이던 호어(Graydon Hoare)에 의해 개발되었습니다. 이후에 모질라에서 공식적으로 후원하게 되고, 2015년 1.0 버전을 릴리즈하였습니다. 쉽고 안전하게 병렬 프로그래밍을 할 수 있는 차세대 프로그래밍 언어입니다.편리한 컴파일러와 소유권 개념 도입으로 보장되는 안정성과 빠른 속도로 인해 C/C++을 대체할 수 있을 것으로 기대되는 언어로 각광 받고 있습니다.러스트 장/단점(개인적 견해) 장점(👍) 함수형 언어 : 함수를 인수로 전달, 다른 함수에서 반환, 변수에 할당하는 등의 방법 사용. 동시성 : 여러 프로세스를 동시에 교차 실행 Ownership :  안전하게 메모리를 관리. Wasm : 컴파일하여 NPM에 패키지로 배포가 가능. (배포된 패키지는 자바스크립트에서 그대로 설치해 사용이 가능) FFI(Foreign function interface) : C/C++, 파이썬등 다른 언어로 작성된 외부 함수를 러스트로 가져와 사용하거나 러스트로 작성한 함수를 다른 언어에서 사용 가능. 호환성 : 하위 버전에 대한 호환성. 단점(👎) 범용성 : 수요가 적고, 자료도 많지 않으며 유효하지 않은 정보가 많음. 커뮤니티와 라이브러리의 부족 : 커뮤니티의 수와 크기가 상대적으로 적고, 라이브러리 및 IDE 지원이 부족함. 난이도 : 개념을 배우는데도 오래걸리고, 문법이 복잡하고 배우기 어려움. 비동기 처리 : 코딩의 어려움과 교착이나 지연 문제. 러스트에서 공식적으로 발표한 잇점 형식 안전 : 컴파일러는 잘못된 형식의 변수에 어떤 작업도 적용되지 않게 보장합니다. 메모리 안전 : Rust 포인터(참조라고도 함)는 항상 유효한 메모리를 참조합니다. 데이터 경합 없음 : Rust의 바로우 검사기는 프로그램의 여러 부분이 동일한 값을 동시에 변경할 수 없도록 하여 스레드 보안을 보장합니다. 무비용 추출 : Rust를 사용하면 최소한의 성능 비용으로, 또는 성능 비용 없이 반복, 인터페이스, 함수 프로그래밍 같은 상위 수준의 개념을 사용할 수 있습니다. 또한 추상화는 기본 코드를 직접 작성하는 것처럼 작동됩니다. 최소 런타임 : Rust에는 최소한의 선택적 런타임이 있습니다. 메모리를 효율적으로 관리할 수 있도록 이 언어에는 가비지 수집기도 없습니다. 이러한 측면에서 Rust는 C 및 C++ 같은 언어와 가장 유사합니다. 운영 체제 미설치 대상 : Rust는 임베디드 및 “운영 체제 미설치” 프로그래밍을 대상으로 지정하여 운영 체제 커널 또는 디바이스 드라이버 작성에 적합하도록 합니다. 러스트 개발 환경 Microsoft C++ Build Tools를 설치하거나 Microsoft Visual Studio를 설치함. VisualStudio Code 설치 (https://code.visualstudio.com/) Rust 설치 (https://www.rust-lang.org/)러스트 설치한국 러스트 사용자 그룹 : https://rust-kr.org/러스트 공식 안내서 (한국어버전) : https://rinthel.github.io/rust-lang-book-ko/foreword.htmlhttps://parksb.github.io/article/35.htmlCargo를 이용한 프로젝트 생성 및 관리Rust 컴파일러(rustc)를 사용하여 크레이트를 직접 만들 수 있지만 대부분의 프로젝트는 Rust 빌드 도구와 Cargo라는 종속성 관리자를 사용합니다." }, { "title": "[ ETC ] 웹소켓", "url": "/posts/websocket/", "categories": "정보, 포맷", "tags": "HTTP, WebSocket, 웹소켓, Comet, 비교", "date": "2022-10-28 06:00:00 +0900", "snippet": "Contents 웹소켓 1. HTTP와 WebSocket의 비교 HTTP WebSocket 공통점 차이점 2. 웹소켓 이전의 실시간 통신 방법(HTTP Comet) polling long polling (Multipart) streaming 3. 웹 소켓 동작 방법 4. 웹소켓 프로토콜의 데이터 프레임 5. 조건에 따른 적절한 활용 http WebSocket 6. 참고 자료웹소켓웹소켓은 HTML5에 포함된 표준 기술로서 HTTP 환경에서 서버와 클라이언트간에 지속적인 연결을 통해 실시간으로 전이중방식(Full-Duplex)의 통신을 가능하게 하는 프로토콜입니다. 단방향(Simplex) 통신 : 한쪽 방향으로만 전송이 가능한 방식 (예) 라디오, TV 전이중(Full-Duplex) 통신 : 동시에 양방향 전송이 가능한 방식으로, 전송량이 많고, 전송 매체의 용량이 클 때 사용 (예) 전화, 전용선을 이용한 데이터 통신 반이중(Half-Duplex) 통신 : 양방향 전송이 가능하지만 동시에 양쪽 방향에서 전송할 수 없는 방식 (예) 무전기, 모뎀을 이용한 데이터 통신 HTTP와 마찬가지로 OSI 제7계층에 속하며, 제4계층의 TCP에 의존적입니다. 2011년 IETF에 의해 RFC 6455로 표준화 되었으며, W3C에 의해 웹 IDL의 웹소켓 API가 표준화 되었습니다. 웹 IDL은 웹 브라우저에 구현되는 Application Programming Interface(API; 응용 프로그램프로그래밍 인터페이스)를 기술하기 위한 Interface Description Language(IDL; 인터페이스 기술 언어) 형식입니다.1. HTTP와 WebSocket의 비교HTTP서버와 클라이언트가 서로 연결을 유지하며 데이터를 관리하면 자원이 필요하기 때문에 요청이 올때만 응답을 함(Stateless) a. 클라이언트의 요청이 있을 때마다 매번 새로운 커넥션을 생성하고 작업이 끝나면 커넥션이 닫힘. (Half-Duplex) b. 형식을 따르기만 하면 쉽게 해석 가능 c. 인터넷 역사상 가장 성공적인 프로토콜(즉시 사용할 수 있는 엄청난 수의 서버/클라이언트 애플리케이션들과 역시 엄청난 수의 (게다가 품질도 뛰어난)라이브러리들을 가지고 있음.)WebSocket한번의 연결으로 지속적으로 서로간 데이터를 보낼 수 있음 (StateFull) a. HTML5 표준 기술, 사용자의 브라우저와 서버 사이의 동적인 양방향 연결 채널을 구성. (Full-Duplex) b. Header가 상당히 작아 Overhead가 적음. c. 형식이 정해져 있지 않아 해석이 어려움. d. UTF8 포멧의 메시지 스트림만 허용 (참고 : 일반 소켓 통신의 경우 Bytes 스트림을 사용)공통점a. OSI 모델 7계층, 4계층의 TCP에 의존 b. 기본적으로 80포트, 443포트 위에 동작(변경 가능) c. HTTP 프록시 및 중간 층을 지원하도록 설계차이점a. 클라이언트에 의해 요청을 받는 방식이 아닌, 서버가 내용을 클라이언트에 보내는 표준화된 방식을 제공 b. 연결이 유지된 상태에서 메시지들을 오갈 수 있게 허용함 c. 양방향 대화 방식 d. 통신은 TCP 포트 80(TLS 암호화 연결의 경우 443)를 통해 수행되며 방화벽을 통해 웹이 아닌 인터넷 연결을 차단하는 일부 환경에 도움. e. TCP 위에서 메시지 스트리밍을 가능케 함. f. TCP 단독으로는 메시지의 상속 개념 없이 바이트 스트림을 다룬다. (?) g. WebSocket 프로토콜은 접속 확립에 HTTP를 사용하지만, 그 후 통신은 WebSocket 독자의 프로토콜로 이루어짐.2. 웹소켓 이전의 실시간 통신 방법(HTTP Comet)Comet은 HTTP상에서 데이터를 push하기 위한 방식 자체를 일컫는 모든 기술을 말합니다. 가장 대표적인 것들은 아래의 3가지가 있습니다.polling 서버로 일정 주기로 요청 실시간 통신에서는 언제 통신이 발생할지 예측이 불가하여, 불필요한 요청과 커넥션이 발생long polling 서버에 요청하고 응답을 받기 전까지 연결을 유지. 많은 양의 메시지가 발생할 경우 polling과 유사.(Multipart) streaming 서버에 요청을 보내고 연속적으로 데이터를 수신. 클라이언트에서 서버로의 데이터 송신이 어려움. Multipart streaming은 multipart/x-mixed-replace를 이용해서, 연결을 끊지 않고 하나의 HTTP 연결에서 데이터를 보내는 방식입니다.. 서버측은 Content-type를 multipart/x-mixed-replace로 하고 스트림 메시지의 boundary를 구분하기 위한 boundary문자를 정의하면 됩니다.3. 웹 소켓 동작 방법연결 수립 과정은 HTTP를 이용합니다. 최초 접속시 HTTP 프로토콜 위에 HandShaking을 위해 HTTP Header를 사용 (기본 포트 HTTP : 80, HTTPS : 443 이용) GET /mychat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chatSec-WebSocket-Version: 13Origin: http://example.com &lt; HTTP기반의 연결을 WebSocket기반으로 upgrade하겠다고 요청하는 과정 &gt; HTTP를 웹소켓 프로토콜로 바꾸기 위해 Protocol switching 과정을 진행 HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat &lt; HTTP를 WebSocket으로 switching 하겠다고 응답하는 과정 &gt; HTTP 대신 WS와 WSS 프로토콜로 데이터 송/수신(UTF8인코딩 데이터를 0x00과 0xff 사이에 데이터를 넣어 보냄) b. 연결 수립 후 서버와 클라이언트 간에 TCP/IP 기반 웹 소켓 연결이 이루어지고, 일정 시간이 지나면 HTTP 연결은 자동으로 끊김 c. 프레임으로 구성된 메시지라는 논리적 단위로 송/수신4. 웹소켓 프로토콜의 데이터 프레임RSV1-3 는 사용되지 않습니다. 이 필드들은 확장 프로토콜 또는 미래를 위해 예약되었습니다.MASK 비트는 메세지가 인코딩되어있는지의 여부를 나타냅니다.클라이언트가 서버로 보내는 메세지는 항상 마스킹되어야합니다. 따라서 서버는 클라이언트로부터 받은 이 필드가 항상 1임을 기대할 수 있습니다. (만약 클라이언트가 마스킹되지 않은 메세지를 보낸다면 서버는 연결을 종료해야 합니다. 참고 : section 5.1 of the spec ). 서버가 클라이언트에게 보내는 메세지는 MASK 필드가 항상 0이고 데이터는 마스킹되지 않은 상태여야 합니다. 마스킹이 어떻게 이루어지는지 / 마스킹된 메세지를 어떻게 디코딩하는지는 나중에 설명합니다. (주의: wss 연결이라고 하더라도 클라이언트가 보내는 패킷은 항상 마스킹되어야 합니다.)opcode 필드는 뒤따라오는 payload 데이터가 어떠한 포멧인지를 나타냅니다. 0x0은 continuation, 0x1은 텍스트(항상 UTF-8), 0x2는 바이너리 데이터 / 나머지 값은 “컨트롤 코드”에 사용됩니다. (컨트롤 코드에 대해서는 나중에 다루게 됩니다.) 현재 버전의 웹소켓 프로토콜에서는 0x3 / 0x7 / 0xB~0xF는 아무런 의미도 지니고있지 않습니다.FIN 비트는 이 메세지가 마지막임을 나타냅니다. 만약 FIN 비트가 0이라면 서버는 뒤에 더 따라오게 될 메세지들까지 수신해야 합니다. FIN 비트가 1일 경우에는 전체 메세지가 수신되었으므로 이를 처리합니다. 이 부분에 대해서는 뒤에 다시 설명합니다.Payload 길이 알아내기수신한 프레임으로부터 payload 데이터를 읽기 위해서는 payload length 필드를 읽어야 합니다. 불행히도 이는 약간 복잡한 작업을 거치는데 아래 순서대로 처리해 주세요.9번째부터 15번째까지의 비트를 읽습니다. 이를 unsigned integer로 취급한 다음 값이 125거나 이보다 작을 경우 이 자체가 payload length 입니다. 이 경우에는 2, 3 과정은 필요 없습니다. 하지만 126이면 2번으로, 127일 경우 3번으로 가주세요다음 16비트를 읽습니다. 이를 unsigned integer로 처리하고 payload length 값으로 사용합니다.다음 64비트를 읽습니다. 이를 unsigned integer로 처리하고 payload length 값으로 사용합니다. (최상위 비트는 항상 0이어야 합니다.)마스킹된 Payload 데이터 디코딩하기MASK 비트가 설정되어 있디만 32비트 사이즈의 Masking-Key 필드 또한 존재하게 됩니다. 아래 의사코드는 Payload 데이터를 ENCODED / Masking-Key 필드를 MASK 라고 가정하고 데이터를 디코딩하는 방법을 보여줍니다. ENCODED값을 0부터 순회하면서 MASK의 i % 4에 해당하는 1바이트와 XOR 연산을 수행합니다.5. 조건에 따른 적절한 활용http 실시간 업데이트가 필요하지 않을 때 단건의 데이터 요청일 때 Restful 서비스로 데이터를 가져올 때 단방향 통신(Half-Duplex) 대표적인 사용 예 : Ajax를 이용한 개발WebSocket 실시간 업데이트가 필요할 때 지속적으로 데이터를 주고 받을 때 양방향 통신(Full-Duplex) 대표적인 사용 예 : 게임, 채팅 앱 등6. 참고 자료 https://velog.io/@gth1123/http-vs-socket https://blog.naver.com/pje0721/222835392496 https://www.joinc.co.kr/w/man/12/websocket https://ws-pace.tistory.com/104 &lt;그림으로 잘 설명됨&gt; https://kbj96.tistory.com/46 https://blog.scaleway.com/iot-hub-what-use-case-for-websockets/ https://velog.io/@ranja/%EC%9B%B9-%EC%86%8C%EC%BC%93%EA%B3%BC-HTTP%EC%9D%98-%EC%B0%A8%EC%9D%B4 https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers https://doozi0316.tistory.com/entry/WebSocket%EC%9D%B4%EB%9E%80-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95-socketio-Polling-Streaming &lt;http header가 잘 설명되어 있음&gt;" }, { "title": "[ C# ] Image.FromFile()을 이용하여 이미지를 불러 올때 락(lock) 문제 해결 방법", "url": "/posts/cs-image-lock/", "categories": "프로그래밍, C# (CSharp)", "tags": "C#, Image.FromFile(), lock, PictureBox", "date": "2022-10-18 18:00:00 +0900", "snippet": "Contents Image.FromFile()을 이용하여 이미지를 불러 올때 락(lock) 문제 해결 방법Image.FromFile()을 이용하여 이미지를 불러 올때 락(lock) 문제 해결 방법C#에서 이미지를 불러올때 Image.FromFile()를 자주 이용하실텐데, 이렇게 불러온 경우 객체를 Dispose() 함수를 호출하기 전까지는 파일에 대한 제어권을 넘겨 받을 수가 없습니다. 대표적인 예로 Picturebox에서 불러오고 해당 파일을 수정하고 저장하려 할때 ERROR_SHARING_VIOLATION(0x20) 오류가 발생할 것입니다.이를 해결하기 위한 방법은 아래와 같습니다. 락(lock) pbxImage.Image = Image.FromFile(\"ImageFile.png\"); 언락(unlock) using (FileStream fs = new FileStream(FileOpenDialog.FileName, FileMode.Open, FileAccess.Read)){ pbxImage.Image = FromStream(fs);} 또는 FileStream fs = new FileStream(FileOpenDialog.FileName, FileMode.Open, FileAccess.Read);pbxImage.Image = FromStream(fs);fs.Close();fs.Dispose(); 와 같이 해주면 안전하게 PictureBox에 그린 이후 곧장 다른 작업을 하실 수 있습니다.참고로 ico 파일인 경우에는 아래와 같이 작업을 해주시면 됩니다.using (FileStream fs = new FileStream(FileOpenDialog.FileName, FileMode.Open, FileAccess.Read)){ Icon myIcon = new System.Drawing.Icon(fs); pbxIcon.SizeMode = PictureBoxSizeMode.StretchImage; pbxIcon.Image = myIcon.ToBitmap();}(※ 여기서 pbxImage와 pbxIcon은 PictureBox 객체 입니다.)" }, { "title": "[ Error ] Visual Studio C# Error 해결 방법", "url": "/posts/err-vcsharp-solved/", "categories": "정보, 에러", "tags": "Error, solved", "date": "2022-10-18 06:00:00 +0900", "snippet": "Contents cs1617 MSB3323cs1617 csc : error cs1617: ‘8.0’은(는) /langversion의 유효한 옵션이 아닙니다. ‘/ langversion:?’를 사용하여 지원되는 값을 나열하세요. 해결방법 : 프로젝트 &gt; 속성 &gt; 빌드 &gt; 고급에서 언어 버전을 C# 최신 부 버전(최신)으로 선택하면 해결이 됩니다. 이렇게 하면 현 Visual Studio에서 사용하고 있는 가장 최근의 C# 언어 버전을 사용할 수 있게 됩니다.MSB3323 error MSB3323: Unable to find manifest signing certificate in the certificate store. warning MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store. 해결방법 : 툴(Visual Studio C#)로 프로젝트를 열고 프로젝트의 “.csproj” 파일을 에디터로 열어서 아래의 항목들을 찾아 제거 합니다.&lt;PropertyGroup&gt; &lt;ManifestCertificateThumbprint&gt;UUID(헥사코드 값)&lt;/ManifestCertificateThumbprint&gt;&lt;/PropertyGroup&gt;&lt;PropertyGroup&gt; &lt;SignManifests&gt;true&lt;/SignManifests&gt;&lt;/PropertyGroup&gt;&lt;PropertyGroup&gt; &lt;ManifestKeyFile&gt;monoslab.pfx&lt;/ManifestKeyFile&gt;&lt;/PropertyGroup&gt; 저장을 하고 툴로 돌아오면 아래와 같은 메시지창이 출력되며, “예(Y)”를 눌러 기존 pfx 파일을 갱신해줍니다. A file with the name ‘D:\\Git\\Monoslab\\VistoApp_TemporaryKey.pfx’ already exists. Do you want to replace it? ✳️ 참고 SignManifests와 ManifestKeyFile를 먼저 삭제하고, 콘솔창에서 해당 프로젝트 이동 후 $&gt; msbuild /fl1 /t:rebuild $&gt; msbuild /fl2 /t:publishonly 를 입력하여 빌드를 진행한 후 툴로 프로젝트를 열고 에디터창에서 ManifestCertificateThumbprint를 삭제하였습니다.혹시나 정상작동 되지 않을 경우 이 “참조” 내용을 참고하여 진행하시기 바랍니다." }, { "title": "[ Flutter ] 플러터를 이용한 윈도우용 앱 개발 (1)", "url": "/posts/flutter_dev_plugin/", "categories": "프로그래밍, Flutter", "tags": "Flutter 3.0, 플러터 3.0, Windows", "date": "2022-09-30 06:00:00 +0900", "snippet": "Contents Windows 네이티브 앱 개발 Windows UI 지원 다양한 샘플들 Plugin 개발 Windows 네이티브 앱 개발Flutter(플러터)는 여러 웹앱과 마찬가지로 웹 컨텐츠를 네이티브 컨테이너(Native container)로 감싸고 있습니다. 내부적으로 네이티브 플랫폼과의 브릿지를 제공합니다.Windows UI 지원Microsoft의 Fluent design system 규칙을 따르는 앱을 개발할 수 있도록 하기 위해 fluent_ui 패키지를 제공하고 있습니다. fluent_ui 패키지에는 네비게이션 뷰, 컨텐츠 다이얼로그, 플라이아웃, 날짜 선택, 트리뷰 위젯등(navigation views, content dialogs, flyouts, date pickers, and tree view widgets)을 제공합니다.또한 Flutter 앱에서 사용할 수 있도록 수천 개의 Fluennt 아이콘을 fluentui_system_icons 패키지를 통해 제공합니다. 이외에도 여러가지 유용한 패키지들이 많지만 마지막으로 bitsdogo_window 패키지를 이용하시면 제목 표시줄을 바꾸는데 용이 합니다. 더 많은 패키지 정보는 아래의 “데스크탑 패키지 및 프로젝트들”의 링크를 참고하세요. 데스크탑 패키지 및 프로젝트들 (Github)다양한 샘플들플러터 공식 사이트에서 제공하는 갤러리 및 Github 샘플입니다. 갤러리 샘플(Repository) 샘플아래는 데스크탑 앱으로 개발된 앱들입니다. Top flutter desktop apps(#1) Top flutter desktop apps(#2)Plugin 개발아래는 플러그인을 프로젝트에 추가하는 방법과 윈도우의 버전 정보를 플러터에서 호출하는 예제입니다.아래와 같은 명령을 입력하면 자동적으로 버전 정보를 얻어 오는 플러그인을 샘플 코드로 생성해줍니다.flutter create -t plugin –platforms=windows,macos example_plugin&gt; flutter create -t plugin --platforms=windows,macos example_pluginCreating project example_plugin...Running \"flutter pub get\" in example_plugin... 1,919msRunning \"flutter pub get\" in example... 2,337msWrote 74 files.All done!pubspec.yaml에서 plugin: platforms: macos: pluginClass: ExamplePlugin windows: pluginClass: ExamplePluginCApi와 같이 잘 적용되었는지 확인 합니다. lib 폴더 아래의 example_plugin.dar 파일을 열어 보시면, 아래와 같이 샘플로 만들어둔 getPlatformVersion 함수가 보일것입니다. 코드 중에 Future1는 싱글스레드 환경에서 비동기 처리를 위해 존재합니다.class ExamplePlugin { Future&lt;String?&gt; getPlatformVersion() { return ExamplePluginPlatform.instance.getPlatformVersion(); } } 이 getPlatformVersion()는 각 플랫폼(각 개발언어)의 plugin에 HandleMethodCall의 getPlatformVersion 함수와 연결이 됩니다. 예를 들어 C++ plugin의 getPlatformVersion 진입점은 아래와 같이 example_plugin.cpp 파일에 정의되어 있습니다.void ExamplePlugin::HandleMethodCall( const flutter::MethodCall&lt;flutter::EncodableValue&gt; &amp;method_call, std::unique_ptr&lt;flutter::MethodResult&lt;flutter::EncodableValue&gt;&gt; result) { if (method_call.method_name().compare(\"getPlatformVersion\") == 0) { std::ostringstream version_stream; version_stream &lt;&lt; \"Windows \"; if (IsWindows10OrGreater()) { version_stream &lt;&lt; \"10+\"; } else if (IsWindows8OrGreater()) { version_stream &lt;&lt; \"8\"; } else if (IsWindows7OrGreater()) { version_stream &lt;&lt; \"7\"; } result-&gt;Success(flutter::EncodableValue(version_stream.str())); } else { result-&gt;NotImplemented(); } } excample_plugin.cpp에는 호출된 함수가 getPlatformVersion 함수인지 비교하여 같으면 버전 정보를 리턴하여 주도록 하는 간단한 예제가 샘플로 들어가 있는것을 보실 수가 있습니다. dart와 각 플랫폼별 HandleMethodCall에서 getPlatformVersion 샘플을 참고하여 함수들을 생성하여 필요한 정보들을 획득하거나 어떤 특정 행동을 수행할 수 있습니다. Future : 어떤 동작이 완료되지 않았더라도 다음 동작을 수행할 수 있도록 해줍니다. &#8617; " }, { "title": "[ Flutter ] Flutter 3.0", "url": "/posts/flutter_3_0/", "categories": "프로그래밍, Flutter", "tags": "Flutter 3.0, 플러터 3.0", "date": "2022-09-06 06:00:00 +0900", "snippet": "Contents Flutter란? Flutter 장/단점(개인적 견해) Flutter 3.0 설치를 위한 환경 Flutter 설치 앱 생성 및 실행 배포 앱 빌드 및 배포 기존 flutter 앱에 다른 지원 디바이스 추가 기타 명령 Flutter란?Flutter(플러터)는 단일 코드로 데스크탑(Windows, MacOS, Linux)와 모바일(Android, iOS), 웹에서 모두 동작하는 앱을 개발할 수 있는 구글에서 개발한 무료 오픈 소스 UI 프레임워크입니다. (참고로 Windows용 앱 개발을 위한 SDK는 2.1 버전 부터 안정화(stable) 버전을 제공하고 있습니다. macOS 및 Linux의 경우는 3 버전 이상 부터 안정화(stable) 버전을 사용할 수 있습니다.) 플러터는 상당히 많은 모듈화된 위젯들을 제공하고 있으며 이를 이용해서 Widget tree1를 쌓아가면서 유저 인터페이스를 구현하는 방식으로 앱을 개발할 수 있습니다.Flutter 장/단점(개인적 견해) 장점 크로스 플랫폼 지원. 핫 리로드 기능(코드 수정후 컴파일 과정을 거치지 않고 빠르게 UI를 확인할 수 있음) UI 안정성(Flutter는 C++ 그래픽 라이브러리(Skia)를 사용하여 UI를 직접 Screen Canvas에서 그림으로서 비교적 안정적인 UI 처리를 할 수 있음) 단점 각 플랫폼별 플러그인 개발에 필요한 언어(C/C++, Swift 등)를 습득해야함. 플러터 개발을 위한 적합한 아키텍쳐를 개발자(?)가 선택해야함. (플러터 개발을 위한 추천 아키텍쳐가 없는것 같음) Flutter 3.0 설치를 위한 환경 OS : Windows 10 or later(64bit), x86-64 기반 디스크 용량 : 1.64GB(IDE/도구를 위한 디스크 공간은 포함하지 않음) 도구 : 플러터는 아래의 도구를 필요로 합니다. Windows PowerShell 5.0 이상(윈도우 10 이상부터는 이미 설치 되어 있음) 윈도우용 Git (Git을 이용하여 최신 버전을 업데이트 하고자 하는 사용자) Visual Studio 2019 이상 또는 Visual Studio Build Tools 2019 이상(설치시 Desktop development with C++”을 선택) Flutter 설치 Flutter SDK 설치 Flutter SDK를 다운받아 설치 합니다. (SDK 릴리즈) 주의 : 특수 문자나 공백이 포함된 경로에 Flutter를 설치 하지 마세요. 주의 : C:\\Program Files\\ 등과 같이 권한 상승이 필요한 디렉토리에 Flutter를 설치 하지 마세요. Git을 통해 안정화 버전을 다운받습니다. C:\\Flutter&gt;git clone https://github.com/flutter/flutter.git -b stable 환경 변수에 경로 설정 윈도우 하단의 검색 시작 표시줄에서 ‘env’를 입력합니다. 『[로그인 사용자 계정]에 대한 사용자 변수』에서 『Path』 항목을 선택하고 편집 버튼을 누릅니다. flutter\\bin 경로를 추가합니다. 개발을 위한 환경 점검flutter doctor를 이용하여 flutter 개발 환경의 문제점을 파악하고 해결할 수 있습니다.C:\\&gt; flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, 3.0.0, on Microsoft Windows [Version 10.0.19044.1706], locale en-US)[✓] Chrome - develop for the web[✓] Visual Studio - develop for Windows (Visual Studio Professional 2022 17.2.0)[✓] VS Code (version 1.67.2)[✓] Connected device (3 available)[✓] HTTP Host Availability• No issues found!flutter devices 를 이용하여 추가 되어 있는 플랫폼를 확인 할 수 있다. C:\\&gt; flutter devices2 connected devices:Chrome (web) • chrome • web-javascript • Google Chrome 105.0.5195.127Edge (web) • edge • web-javascript • Microsoft Edge 105.0.1343.53flutter config를 이용하여 개발에서 제외 하고자하는 플랫폼을 지정할 수 있습니다.--no-enable-windows-desktop--no-enable-linux-desktop--no-enable-macos-desktop--no-enable-web--no-enable-android--no-enable-ios C:\\&gt; flutter config --no-enable-ios반대로 flutter config를 이용하여 개발에 포함하고 싶은 플랫폼을 지정할 수도 있습니다.--enable-windows-desktop--enable-linux-desktop--enable-macos-desktop--enable-web--enable-android--enable-ios C:\\&gt; flutter config --enable-ios앱 생성 및 실행아래와 같이 명령을 입력하여 앱을 생성합니다.&gt; flutter create my_app&gt; cd my_app아래와 같이 명령을 입력하여 앱을 실행합니다.&gt; flutter run -d windows (또는 macos, linux 등)(* 참고 : d 플래그를 입력하지 않으면 flutter run에서 선택할 수 있는 대상이 나옵니다.)Launching lib\\main.dart on Windows in debug mode… Exception: No Windows desktop project configured. See https://docs.flutter.dev/desktop#add-desktop-support-to-an-existing-flutter-app to learn about adding Windows support to a project. 와 같은 오류 발생시 “flutter create .” 명령 입력후 다시 위의 명령을 수행하면 된다. (* 참고 : flutter create –platforms=windows 으로 미리 설정해주면 오류가 발생되지 않음)배포 앱 빌드 및 배포릴리즈 파일을 생성하려면 아래와 같이 입력합니다.&gt; flutter build windows (또는 macos, linux 등)배포시 build\\windows\\runner\\Release 내의 파일 모두와 아래의 파일들을 함께 배포합니다.Release│ flutter_windows.dll│ msvcp140.dll│ my_app.exe│ vcruntime140.dll│ vcruntime140_1.dll│└───data│ │ app.so│ │ icudtl.dat ...기존 flutter 앱에 다른 지원 디바이스 추가기존 flutter 프로젝트에 윈도우, 맥, 리눅스 등 다른 데스크탑 지원을 추가하려면 아래와 같이 명령어를 입력합니다.&gt; flutter create --platforms=windows,macos,linux기타 명령다른 개발자가 개발한 프로그램을 불러왔을 때 패키지가 나의 PC에는 없을 수가 있는데, 이는 아래의 명령으로 패키지를 쉽게 가져올 수가 있습니다.&gt; flutter pub get Widget Tree : React의 component tree 또는 Html DOM tree와 같은 개념으로 UI Compoent를 모두 사각형으로 분해합니다 &#8617; " }, { "title": "[ Project ] Smart Update 설계 및 개발", "url": "/posts/smart-update/", "categories": "프로젝트", "tags": "프로젝트, 자동, 업데이트, smart, update", "date": "2022-08-23 06:00:00 +0900", "snippet": "Contents Smart Update 설계 Smart Update UI Smart Update 흐름 직접 실행 앱을 통한 실행 업데이트 STEP 설정 파일 및 업데이트 정보 파일 SmartUpdate.json 예시 udi.dat 예시 Smart Update 설계프로그램 배포시 업데이트를 매번 프로그램에 맞게 커스트마이징하여 개발을 하였는데, 매번 불필요한 공수가 들어가게 되어 공용으로 사용 가능한 Smart한 Update 프로그램을 개발하였습니다.Smart Update UI 업데이트의 상단 이미지는 프로그램 실행시 이미지 파일에서 읽어 들여 처리합니다. 업데이트가 진행 중인 경우에는 우측 하단의 버튼은 취소로 표시되며, 완료된 경우에는 확인 버튼으로 표시됩니다. 취소 : 업데이트를 진행 했던 파일들을 다시 복원하고 종료합니다. 확인 : 업데이트를 위해 백업했던 파일들을 모두 삭제합니다. Smart Update 흐름업데이트 방법은 크게 두가지로 구분이 되는데, 업데이트 프로그램을 직접 실행하여 처리하는 방법과 프로그램에 의해 실행이 되는 방법이 있습니다직접 실행설정 파일(smartupdate.json)에서 도메인 정보와 버전 정보를 얻어올 수 있는 경로를 획득하여 직접 업데이트를 수행합니다. 업데이트시 업데이트 항목 중 현재 실행중인 프로세스가 있는 경우 해당 프로세스의 정보를 저장하고 프로세스를 종료시킵니다. 업데이트할 파일을 모두 다운로드 한 경우 업데이트시에 종료되었던 프로세스를 되살리고 업데이트 프로그램을 종료합니다. 만약 업데이트할 파일에 업데이트와 관련된 파일이 존재할 경우 업데이트 에이전트를 실행시켜서 업데이트의 마지막 작업(사용중이던 프로세스 재실행)을 위임합니다.앱을 통한 실행앱에서 버전 정보를 비교하고 SmartUCore.dll에서 업데이트 목록을 생성(udi.dat)하고 업데이트 파일(SmartUpdate.exe)을 실행합니다. 이후의 작업은 “직접 실행” 작업과 동일한 작업을 수행합니다.업데이트 STEP설정 파일 및 업데이트 정보 파일SmartUpdate.json 예시{ \"lang\": \"ko\", \"preferFromFile\": false, \"preferFile\": \"MonoToolbox.json\", \"protocolDesc\": \"http(0), https(1)\", \"protocol\": 0, \"domain\": \"monoslab.github.io\", \"urlPath\": \"/component/install/{DOMAIN}/toolbox/\", \"dnlPath\": \"Not used. Prepare for future customization.\", \"port\": 80, \"attachPort\": false, \"versionFile\": { \"server\": \"ver.txt\", \"client\": \"ver.txt\" }, \"serviceList\": [{ \"name\": \"MonoService\", \"file\": \"MonoServiceNew.exe\", \"comment\": \"Monosoft 제품군에 대한 관리 프로그램입니다.\" }, { \"name\": \"MonoHwpDraft\", \"file\": \"MonoHwpDraftNew.exe\", \"comment\": \"Monosoft 한글실행기 서비스 프로그램입니다.\" } ]} lang : 기본 언어(SmartUpdate를 직접 실행할 경우 사용) preferFromFile : 환경정보를 다른 파일로 부터 얻어오는지에 대한 여부 preferFile : preferFromFile이 true값을 가질때 환경정보를 얻어 올 파일명 protocol : 프로토콜 (http의 경우 0, https의 경우 1을 설정) domain : 도메인 urlPath : 버전 파일 또는 업데이트 파일을 다운로드할 경로 dnlPath : 현재에는 사용하지 않음. 로컬의 특정 위치에 파일을 저장해야할 경우 사용. port : 사용 포트(http 기본 : 80, https 기본 : 443) attachPort : URL에 포트를 붙여서 사용할지 여부 versionFile : 버전 파일 server : 서버의 버전 파일명 client : 로컬의 버전 파일명 serviceList : 서비스 파일 정보 name : 서비스명 file : 서비스 파일명 comment : 서비스 설명 udi.dat 예시{ \"attachPort\" : false, \"domain\" : \"monoslab.github.io\", \"lang\" : \"ko\", \"list\" : [ \"MonoBrowser.exe\", \"MonoCapture.exe\", \"MonoCubro.exe\", \"MonoToolBox.exe\" ], \"locfile\" : \"D:\\\\00. Project\\\\git\\\\SmartUpdate2\\\\Release\\\\ver.txt\", \"port\" : 80, \"protocol\" : 0, \"raw\" : \"\", \"serviceList\" : null, \"tmpfile\" : \"C:\\\\Users\\\\mono\\\\AppData\\\\Roaming\\\\Monosoft\\\\Update\\\\ver.txt\", \"urlPath\" : \"/component/install/monoslab_github_io/toolbox\"} attachPort : URL에 포트를 붙여서 사용할지 여부 domain : 도메인 lang : 설정 언어 list : 업데이트할 파일의 목록 locfile : 로컬 버전 파일 port : 사용 포트(http 기본 : 80, https 기본 : 443) protocol : 프로토콜 (http의 경우 0, https의 경우 1을 설정) raw : 서버로 부터 다운 받은 버전 데이터 (raw 값이 null인 경우 아래의 tmpfile을 이용) serviceList : 업데이트 할 서비스 리스트 tmpfile : 서버로 부터 다운 받은 버전 파일 urlPath : 업데이트 파일을 다운로드할 경로" }, { "title": "[ 사례 ] 바이러스 오진 사례", "url": "/posts/virus-misdiagnosis-case/", "categories": "정보, 에러", "tags": "virus, solved", "date": "2022-08-12 06:00:00 +0900", "snippet": "Contents 알약(Alyak)에서의 바이러스 오진 사례알약(Alyak)에서의 바이러스 오진 사례 case 1 : Visual Studio 2017에서 컴파일 후 알약에서 바이러스로 오진을 함. 변경전 : 구성 &gt; 구성 속성 &gt; 일반 &gt; MFC 사용 &gt; 공유 DLL에서 MFC 사용 구성 &gt; 구성 속성 &gt; C/C++ &gt; 코드 생성 &gt; 런타임 라이브러리 &gt; 다중 스레드DLL(/MD) 변경후 : 구성 &gt; 구성 속성 &gt; 일반 &gt; MFC 사용 &gt; 정적 라이브러리에서 MFC 사용 구성 &gt; 구성 속성 &gt; C/C++ &gt; 코드 생성 &gt; 런타임 라이브러리 &gt; 다중 스레드(/MT) case 2 : Visual Studio 2022에서 컴파일 후 알약에서 바이러스로 오진을 함. 구성 &gt; 구성 속성 &gt; 일반 &gt; MFC 사용 &gt; 정적 라이브러리에서 MFC 사용 구성 &gt; 구성 속성 &gt; C/C++ &gt; 코드 생성 &gt; 런타임 라이브러리 &gt; 다중 스레드(/MT) 변경전 : Win32(x86) 플랫폼의 Release 버전으로 컴파일시 바이러스 감지 (탐지명 : Gen:Variant.Fragtor.533355) 변경후 : x64 플랫폼의 Release 버전으로 컴파일 후 바이러스 감지되지 않음. case 3 : Visual Studio 2022에서 컴파일 후 알약에서 바이러스로 오진을 함. 변경전 : Visual Studio 2022 version 17.10.4 사용 x64 플랫폼의 Release 버전으로 컴파일시 바이러스 감지 (탐지명 : Gen:Variant.Tedy.618274) 변경후 : Visual Studio 2022 version 17.10.5 업그레이드 후 x64 플랫폼의 Release 버전으로 컴파일시 발생하지 않음. (참조 : 구글링시 Visual Studio tool의 버전에 따라 발생되는 경우가 있다는 글이 간혹 보임.) " }, { "title": "[ Error ] Jekyll Error 해결 방법", "url": "/posts/err-jekyll-solved/", "categories": "정보, 에러", "tags": "Error, solved", "date": "2022-08-11 06:00:00 +0900", "snippet": "Contents ERROR: Invalid first code point of tag name U+B9AC Liquid Exception: undefined method ‘gsub’ for 3.0 ERROR: Eng tag ‘h2’ isn’t allowed here. The process ‘/opt/hostedtoolcache/Ruby/…/bin/bundle’ failed with exit code 5ERROR: Invalid first code point of tag name U+B9AC ERROR: Invalid first code point of tag name U+B9AC 해결방법 : md 파일 내에 잘못 사용된 tag로 인하여 발생되는 에러 이며 tag가 아닌 부분은 명시적으로 tag가 아님을 확인 시켜주어야 합니다. &lt;와 &gt;의 앞에 \\ 를 넣어주시면 해결이 됩니다. 아래는 해당 오류의 예입니다. 오류 발생 : https://raw.githubusercontent.com/&lt;사용자 이름&gt;/&lt;리포지토리 이름&gt;/master/&lt;파일명&gt; 화면 표시 : https://raw.githubusercontent.com/&lt;사용자 이름=””&gt;/&lt;리포지토리 이름=””&gt;/master/&lt;파일명&gt; 오류 해결 : https://raw.githubusercontent.com/\\ &lt;사용자 이름&gt;/\\ &lt;리포지토리 이름\\ &gt;/master/\\ &lt;파일명\\ &gt; Liquid Exception: undefined method ‘gsub’ for 3.0 Liquid Exception: undefined method ‘gsub’ for 3.0:Float string.gsub(replaceable_char, “-“)Liquid Exception: undefined method `gsub' for 3.0:Float string.gsub(replaceable_char, \"-\") ^^^^^ in E:/Github/monoslab.github.io/_layouts/post.html ------------------------------------------------ Jekyll 4.2.2 Please append `--trace` to the `serve` command for any additional information or backtrace. ------------------------------------------------ C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/utils.rb:364:in `replace_character_sequence_with_hyphen': undefined method `gsub' for 3.0:Float (NoMethodError) string.gsub(replaceable_char, \"-\") ^^^^^ 해결방법 : tags의 배열에 숫자값이 먼저 나오는 경우 해당 오류를 발생시킵니다. 아래는 해당 오류의 예입니다. 오류 발생 : tags: [Error, TBC, 3.0] 오류 해결 : tags: [Error, TBC 3.0] — ERROR: Eng tag ‘h2’ isn’t allowed here. ERROR: Eng tag ‘h2’ isn’t allowed here. Currently open tags: html, body, div, div, div, div, div, div, h2, span. 해결방법 : 빌드시 타이틀(#, ## 등)에 span 태그 사용시 span 태그가 생기는 버그로 인해 문제가 발생되어 span 태그를 제거함.The process ‘/opt/hostedtoolcache/Ruby/…/bin/bundle’ failed with exit code 5 The process ‘/opt/hostedtoolcache/Ruby/3.3.0/x64/bin/bundle’ failed with exit code 5 해결방법 : 루트 아래의 ‘.github\\workflows’ 폴더에서 ci.yml, pages-deploy.yml의 Ruby 버전을 변경하여 줍니다.ci.yml 수정jobs: build: ... steps: ... - name: Setup Ruby uses: ruby/setup-ruby@v1 with: ruby-version: 3.2pages-deploy.yml 수정jobs: continuous-delivery: ... steps: - name: Setup Ruby uses: ruby/setup-ruby@v1 with: ruby-version: 3.2" }, { "title": "[ VC++ ] GitHub을 이용하여 애플리케이션 자동 업데이트", "url": "/posts/auto-update-from-github/", "categories": "프로그래밍, C++ (CPP)", "tags": "GitHub, 자동, 업데이트, auto, update", "date": "2022-08-05 06:00:00 +0900", "snippet": "Contents GitHub을 이용하여 애플리케이션 자동 업데이트 GitHub api를 이용하는 방법 RAW 데이터를 이용하는 방법 GitHub을 이용하여 애플리케이션 자동 업데이트( 작성 중 💦 ) 많은 개발자들로 부터 널리 사용되고 있는 리포지토리인 GitHub을 이용하여 애플리케이션의 릴리스 버전을 자동으로 관리하는 방법에 대해 알아보려고 합니다.GitHub api를 이용하는 방법GitHub에 저장소를 생성하고 나면 저장소 우측에 Release 링크가 있는 것을 확인하실수 있습니다.(아래의 이미지 참조)Create a new release를 클릭한 후 아래와 같은 방법으로 적절하게 내용을 작성하고 파일을 추가해 줍니다.파일은 업데이트 파일 외에도 버전을 관리할 수 있는 파일(version.dat)도 함께 올려 줍니다. https://api.github.com/repos/&lt;사용자 이름&gt;/&lt;리포지토리 이름&gt;/releases json 데이터에서 버전정보 확인 후 다운로드 방식 api를 이용하여 버전 정보 확인 raw 데이터를 읽어 파일을 저장RAW 데이터를 이용하는 방법생성한 저장소에 파일을 직접 호출 또는 다운로드 하는 방법입니다. https://raw.githubusercontent.com/&lt;사용자 이름&gt;/&lt;리포지토리 이름&gt;/master/&lt;파일명&gt; 버전 파일을 먼저 다운로드하여 업그레이드가 필요한 파일만 다운로드 하는 방식.업데이트 파일을 관리할 서버는 위의 방법으로 구축하였으면, 절반의 작업은 끝났습니다. 다음은 업데이트를 적용할 수 있도록 애플리케이션에 업데이트를 위한 코드를 작성하여야 합니다. GitHub 서버로 부터 version.dat 파일을 다운로드 로컬 버전 정보와 비교 다운로드 목록 생성 및 다운로드" }, { "title": "[ Windows ] 윈도우 실행키(Win + R) 입력 명령어 목록", "url": "/posts/win-r/", "categories": "정보, 윈도우", "tags": "윈도우, 명령, WIN, R", "date": "2022-07-31 18:00:00 +0900", "snippet": "Contents 윈도우 실행키(Win + R) 입력 명령어 목록 시스템 도구 관련 명령어 제어판 관련 명령어 프로그램 관련 명령어 윈도우 실행키(Win + R) 입력 명령어 목록키보드에서 윈도우 로고 키와 R 키를 동시에 누르면 실행 창이 열리고 입력란에 명령어를 입력하면 윈도우 시스템 도구 및 각종 명령을 손쉽게 불러와 사용할 수 있습니다.시스템 도구 관련 명령어 명령 설명 mdingo32 시스템 정보 taskmgr 작업 관리자 winver Windows 정보 msconfig 시스템 구성 compmgmt.msc 컴퓨터 관리 devmgmt.msc 장치 관리자 diskmgmt.msc 디스크 관리 lusrmgr.msc 로컬 사용자 및 그룹 gpedit.msc 그룹 정책 fgsmgmt.msc 공유 폴더 certmgr.msc 인증서 관리 eventvwr(.msc) 이벤트 뷰어 perfmon.msc 성능 모니터 secpol.msc 로컬 보안 설정 services.msc 서비스 comexp.msc 구성 요소 서비스 compmgmtlauncher 컴퓨터 관리 (일반 윈도우) compmgmt.msc 서버 관리자 (서버 윈도우) sf.msc 방화벽 고급 설정 taskschd.msc 작업 스케줄러 tsconfig.msc 터미널 관리 ciadv.msc 인덱싱 서비스 wmimgmt.msc WMI 서비스 구성 inetmgr IIS 관리자 dnsmgr DNS 관리 wdsmgr WDS 배포 서비스 dhcpmgr DHCP 관리 netplwiz 사용자 계정 제어판 관련 명령어 명령 설명 control system 시스템 sysdm.cpl 시스템 속성 ncpa.cpl 네트워크 연결 firewall.cpl 방화벽 설정 appwiz.cpl 프로그램 추가/제거 hdwwiz.cpl 장치관리자 mmsys.cpl 사운드 및 오디오 장치 desk.cpl 디스플레이 inetcpl.cpl 인터넷 옵션 intl.cpl 국가 및 언어 옵션 main.cpl 마우스 powercfg.cpl 전원 옵션 wdcui.cpl 관리 센터 timedate.cpl 날짜 및 시간 control admintools 관리 도구 control userpasswords2 사용자 계정 프로그램 관련 명령어 명령 설명 cmd 명령 프롬프트 mstsc 원격 데스크탑 연결 msra 원격 지원 mrt 악성 소프트웨어 제거 도구 dfrgui 디스크 조각 모음 cleanmgr 디스크 정리 snippingtool 캡쳐 도구 write 워드패드 mspaint 그림판 notepad 메모장 calc 계산기 dxdiag 다이렉트X 진단도구 explorer 탐색기 osk 화상키보드 " }, { "title": "[ Windows ] 디스크 100% 문제 해결 방법", "url": "/posts/info-disk-100/", "categories": "정보, 윈도우", "tags": "디스크, 100%", "date": "2022-07-29 01:00:00 +0900", "snippet": "Contents 윈도우 10에서 디스크 100%가 되는 현상 &lt; 해결 방법 1 &gt; 서비스 중지 &lt; 해결 방법 2 &gt; Windows에 대한 팁 표시 끄기 &lt; 해결 방법 3 &gt; 가상 메모리 크기 조절 &lt; 해결 방법 4 &gt; Message Signaled Interrupt (MSI) 비활성화 윈도우 10에서 디스크 100%가 되는 현상&lt; 해결 방법 1 &gt; 서비스 중지 AppX Deployment Service Superfetch (Sysmain) Windows Search Background Intelligent Transfer Service Connected User Experiences and Telemetry🎫 AppX Deployment Service (AppXSVC)는 윈도우 8.1 이상의 버전에서 자동으로 윈도우에서 지원하는 스토어 앱(Widnows Store App) 실행을 위한 프로세스입니다. 서비스 삭제는 하지 않는 편이 좋을 듯 싶습니다. 나중에 스토어 앱을 사용할 경우도 생길 수 있기 때문에 disabled까지만 진행하는 것으로… 😄😄😄 (* 참고 : 스토어에서 앱을 다운받아 사용하면 이 옵션을 끌 경우 실행이 안될 수도 있다고 합니다.)이 서비스를 사용하지 않는 방법은 명령 프롬프트(Command prompt)를 관리자 권한으로 열고, 아래의 명령어를 차례대로 입력하면 됩니다.sc stop \"AppXSvc\" sc config \"AppXSvc\" start= disabled 참고 : sc stop xxx 명령어는 net.exe stop xxx 명령으로 바꾸어 사용 하셔도 동일한 작업을 수행합니다. 다른 종료 방법: Win key + R &gt; services.msc 입력 &gt; “AppX Deployment Service (AppXSVC)” 이름에 우클릭 &gt; 속성 &gt; 시작 유형 : 사용 안함, 서비스 상태 : 중지서비스를 삭제하는 방법은 아래와 같습니다.sc delete \"AppXSvc\"🎫 Superfetch는 애플리케이션을 더 빠르게 실행하고 시스템 응답 속도를 개선하기 위한 Windows 서비스입니다. 자주 사용하는 프로그램을 RAM에 미리 로드하여 실행할 때마다 하드 드라이브에서 호출할 필요가 없도록 합니다. 이 서비스가 컴퓨터 성능에 영향을 미치는 경우 해당 서비스를 끄는 것이 좋습니다.위에 설명 드렸던 동일한 방법으로 명령 프롬프트를 관리자 권한으로 열고 아래의 명령어를 입력하시면 됩니다. 이후 부터는 동일하게 입력하면 되기 때문에 따로 설명을 하지 않겠습니다. (shell 부분은 명령 프롬프트를 관리자 권한으로 열고 입력하시면 됩니다.)sc stop \"superfetch\"sc config \"superfetch\" start= disabled superfetch가 없는 경우 Sysmain으로 입력하여 주세요. 이는 2018 년 10월 윈도우즈 업데이트에서 Superfetch는 Sysmain으로 변경되었기 때문이며, 이름만 변경되었을 뿐 하는 역활은 동일합니다. 다른 종료 방법: Win key + R &gt; services.msc 입력 &gt; “SysMain” 이름에 우클릭 &gt; 속성 &gt; 시작 유형 : 사용 안함, 서비스 상태 = 중지🎫 Windows search(WSearch)는 파일, 전자 메일 및 기타 콘텐츠에 대한 콘텐츠 인덱싱, 속성 캐싱 및 검색 결과를 제공합니다.sc stop \"WSearch\"sc config \"WSearch\" start= disabled 다른 종료 방법: Win key + R &gt; services.msc 입력 &gt; “Windows Search” 이름에 우클릭 &gt; 속성 &gt; 시작 유형 : 사용 안함, 서비스 상태 = 중지🎫 Background Intelligent Transfer Service(BITS)는 컴퓨터 간에 동시 파일 전송을 수행하기 위해 사용하지 않는 네트워크 대역폭을 사용하는 Microsoft Windows 운영 체제의 구성 요소입니다. BITS 는 포그라운드 또는 백그라운드에서 비동기 파일 전송을 수행합니다. BITS는 응용 프로그램의 파일 전송 요청에 우선 순위를 지정하는 대기열 관리 기능을 제공합니다. 중단이 발생하면 BITS는 자동으로 다시 연결하고 네트워크나 컴퓨터가 서비스를 재개할 때 파일 전송을 재개합니다.sc stop \"bits\"sc config \"bits\" start= disabled 다른 종료 방법: Win key + R &gt; services.msc 입력 &gt; “Background Intelligent Transfer Service” 이름에 우클릭 &gt; 속성 &gt; 시작 유형 : 사용 안함, 서비스 상태 = 중지🎫 Connected User Experiences and Telemetry는 윈도우 사용자 데이터를 수집하는 진단/추적하고 데이터를 Microsoft 서버에 주기적으로 보내는 역활을 합니다. 개인적인 생각으로는 정말 쓸모없는 프로세스이기 때문에 삭제는 하지 못하더라도 비활성화를 통해서 꺼버리는것을 추천드립니다. 시스템 부하 및 컴퓨터 속도를 느리게 하는 원인중 하나입니다.sc stop \"DiagTrack\"sc config \"DiagTrack\" start=disabled 다른 종료 방법: Win key + R &gt; services.msc 입력 &gt; “Connected User Experiences and Telemetry” 이름에 우클릭 &gt; 속성 &gt; 시작 유형 : 사용 안함, 서비스 상태 = 중지&lt; 해결 방법 2 &gt; Windows에 대한 팁 표시 끄기윈도우를 사용할때 윈도우는 수행 중인 작업을 감시하고 운영 체제와 관련하여 수행될때에는 작업에 대한 팁을 제공합니다. 하지만 대부분의 “팁”이 도움이 되는 경우가 별로 없습니다. 아래와 같은 방법으로 Windows에 대한 팁을 끌 수 있습니다. Win key + R &gt; desk.cpl 입력 &gt; 알람 및 작업 &gt; 각종 알람을 끄기 (불필요한 알림은 꺼주시고, “Windows에 대한 팁 표시”를 끄도록 합니다.)&lt; 해결 방법 3 &gt; 가상 메모리 크기 조절이 방법은 부족한 메모리로 인해 발생될 수 있을 가능성이 있기 때문에 사용하는 방법이며, 메모리가 충분한 상황에서는 효과가 미미합니다. Win key + R &gt; sysdm.cpl 입력 &gt; 고급 &gt; 성능 : 설정 &gt; 고급 &gt; 가상 메모리 : 변경“모든 드라이브에 대한 페이징 파일 크기 자동 관리(A)” 해제사용자 지정 크기 (적절하게 용량을 할당)드라이브가 여러 개 있는 경우 주 드라이브만 설정하시고 나머지는 “페이징 파일 없음(N)”을 선택하셔도 됩니다.&lt; 해결 방법 4 &gt; Message Signaled Interrupt (MSI) 비활성화https://www.dell.com/support/kbdoc/ko-kr/000125194/windows-10-task-manager-reports-100-disk-utilization-with-msi-mode-enabledMessage Signaled Interrupt (MSI)는 전용 인터럽트 라인 의 기존 대역 외 주장 을 대체하기 위해 특수 대역 내 메시지를 사용하여 인터럽트 를 신호하는 대체 대역 내 방법입니다. 장치에서 구현하기가 더 복잡하지만 메시지 신호 인터럽트는 핀 기반 대역 외 인터럽트 신호보다 몇 가지 중요한 이점이 있습니다. 메시지 신호 인터럽트는 버전 2.2 이후 PCI 버스와 이후에 사용 가능한 PCI Express 버스에서 지원됩니다. 일부 비 PCI 아키텍처는 메시지 신호 인터럽트도 사용합니다. (* WIKI 참고 : https://en.wikipedia.org/wiki/Message_Signaled_Interrupts)아래의 방법은 레지스트리를 잘못 건드릴 경우 시스템에 심각한 오류를 유발할 수 있으므로 가급적 인터넷에서 AHCI 컨트롤러를 다시 한번 검색하여 학습하시고 수정하시길 바랍니다.Microsoft에서는 특정 장치에 대한 MSI 모드를 비활성화하기 위해 아래와 같이 레지스트리를 수정하는 방법을 제공하고 있습니다.1. 시스템에서 기본 AHCI 드라이버(StorAHCI.sys)를 실행하고 있는지 확인합니다. 1) Win Key + R &gt; devmgmt.msc &gt; IDE ATA/ATAPI에서 우클릭 &gt; 속성 &gt; 드라이버 : 드라이버 정보(I) : StorAHCI.sys가 있으면 기본 드라이버를 실행하고 있는 것입니다. (* 참고 : IDE ATA/ATAPI 는 일반적으로 장치 관리자를 통해 확인 할 수 있으나, 메인 보드 드라이버를 업데이트하지 않으면 장치 관리자에 표시되지 않을 수 있으며, 장치에 따라 존재하지 않을 수 있습니다.)2. 실행되고 있다면 다음과 같이 레지스트리에서 컨트롤러에 대한 MSI를 비활성화합니다. 1) Win Key + R &gt; devmgmt.msc &gt; IDE ATA/ATAPI에서 우클릭 &gt; 속성 &gt; 드라이버 : 드라이버 정보(I)에서 장치(Device) 인스턴스 경로를 기록해 두세요. 2) Win Key + R &gt; regeidt 입력(레지스트리 편집기 실행) : HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Enum\\PCI\\&lt;AHCI Controller&gt;\\Device Parameters\\Interrupt Management\\MessageSignaledInterruptProperties로 이동 3) MSISupported의 값을 1에서 0으로 변경 3. 시스템을 재부팅합니다." }, { "title": "[ VC++ ] MSVC 버전 (_MSC_VER, _MSC_FULL_VER)", "url": "/posts/cpp-msc-version/", "categories": "정보, 포맷", "tags": "VC++, _MSC_VER, _MSC_FULL_VER, MSVC, Version", "date": "2022-07-19 02:00:00 +0900", "snippet": "Contents Visual Studio C++ 버전 관리 규칙 Visual Studio 버전 체크Visual Studio C++ 버전 관리 규칙MSVC 컴파일러 버전은 주 버전, 부 버전, 빌드 버전, 수정 버전으로 구성이 되어 있습니다. 컴파일러 매크로 아래의 이미지와 같은 방식으로 필드를 인코딩합니다. 예를 들어 Visual Studio 2022 버전 17.9.2의 컴파일러 버전은 19.39.33521 이라 가정하면, 주 버전 : 19 부 버전 : 39 빌드 버전 : 33521 수정 버전 : 0 이며, 아래와 같은 매크로 값을 가집니다. Visual Studio 버전 체크Visual Studio의 버전을 체크하여 버전에 맞게 컴파일 할 수 있도록 적용할 수 있습니다. _MSC_VER는 버전의 주 번호 및 부 번호 요소를 변하지 않는 정수값(리터럴)으로 정의합니다. 주 번호는 마침표로 구분된 버전 번호의 첫 번째 요소이며, 부 번호는 두 번째 요소입니다. 예를 들어 Microsoft C/C++ 컴파일러의 버전 번호가 19.00.24234.1인 경우 _MSC_VER 매크로를 실행하면 1900이 나옵니다. 컴파일러의 버전 번호를 보려면 “명령 프롬프트”에서 cl 명령어를 입력하면 확인할 수 있습니다. 참고로 _MS_FULL_VER을 이용하여 빌드 버전까지 포함된 버전값도 얻어 올수도 있습니다. 이 두 값은 항상 정의되어져 있습니다.아래와 같이 컴파일러에 맞게 소스를 적용하여 컴파일 할 수 있습니다.#if _MSC_VER &gt;= 1910// . . .#elif _MSC_VER &gt;= 1900// . . .#else// . . .#endif 표기 Visual Studio version VC ++version _MSC_VER _MSC_FULL_VER 2022 Update 14 Visual Studio 2022 version 17.14.9 14.44 1944 194435213 2022 Update 13 Visual Studio 2022 version 17.13.0 14.43 1943 194334808 2022 Update 12 Visual Studio 2022 version 17.12.4 14.42 1942 194234433 2022 Update 11 Visual Studio 2022 version 17.11.6 14.41 1941 194134123 2022 Update 11 Visual Studio 2022 version 17.11.3 14.41 1941 194134120 2022 Update 10 Visual Studio 2022 version 17.10.1 14.40 1940 194033811 2022 Update 9 Visual Studio 2022 version 17.9.6 14.39 1939 193933523 2022 Update 9 Visual Studio 2022 version 17.9.2 14.39 1939 193933521 2022 Update 8 Visual Studio 2022 version 17.8.3 14.38 1938 193833133 2022 Update 7 Visual Studio 2022 version 17.7.0 14.37 1937 193732822 2022 Update 6 Visual Studio 2022 version 17.6.4 14.36 1936 193632535 2022 Update 6 Visual Studio 2022 version 17.6.2 14.36 1936 193632532 2022 Update 5 Visual Studio 2022 version 17.5.0 14.35 1935   2022 Update 4 Visual Studio 2022 version 17.4.0 14.34 1934 193431933 2022 Update 3 Visual Studio 2022 version 17.3.4 14.33 1933 193331630 2022 Update 2 Visual Studio 2022 version 17.2.2 14.32 1932 193231329 2022 Update 1 Visual Studio 2022 version 17.1.0 14.31 1931   2022 Visual Studio 2022 version 17.0.2 14.30 1930 193030706 2022 Visual Studio 2022 version 17.0.1 14.30 1930 193030705 2019 Update 11 Visual Studio 2019 version 16.11.49 14.29 1929 192930159 2019 Update 11 Visual Studio 2019 version 16.11.34 14.29 1929 192930154 2019 Update 11 Visual Studio 2019 version 16.11.27 14.29 1929 192930151 2019 Update 11 Visual Studio 2019 version 16.11.24 14.29 1929 192930148 2019 Update 11 Visual Studio 2019 version 16.11.2 14.29 1929 192930133 2019 Update 9 Visual Studio 2019 version 16.9.2 14.28 1928 192829913 2019 Update 8 Visual Studio 2019 version 16.8.2 14.28 1928 192829334 2019 Update 8 Visual Studio 2019 version 16.8.1 14.28 1928 192829333 2019 Update 7 Visual Studio 2019 version 16.7 14.27 1927 192729112 2019 Update 6 Visual Studio 2019 version 16.6.2 14.26 1926 192628806 2019 Update 5 Visual Studio 2019 version 16.5.1 14.25 1925 192528611 2019 Update 4 Visual Studio 2019 version 16.4.0 14.24 1924 192428314 2019 Update 3 Visual Studio 2019 version 16.3.2 14.23 1923 192328105 2019 Update 2 Visual Studio 2019 version 16.2.3 14.22 1922 192227905 2019 Update 1 Visual Studio 2019 version 16.1.2 14.21 1921 192127702 2019 Visual Studio 2019 version 16.0.0 14.20 1920 192027508 2017 Update 9 Visual Studio 2017 version 15.9.75 14.16 1916 191627054 2017 Update 9 Visual Studio 2017 version 15.9.60 14.16 1916 191627051 2017 Update 9 Visual Studio 2017 version 15.9.11 14.16 1916 191627030 2017 Update 9 Visual Studio 2017 version 15.9.7 14.16 1916 191627027 2017 Update 9 Visual Studio 2017 version 15.9.5 14.16 1916 191627026 2017 Update 9 Visual Studio 2017 version 15.9.4 14.16 1916 191627025 2017 Update 9 Visual Studio 2017 version 15.9.1 14.16 1916 191627023 2017 Update 9 Visual Studio 2017 version 15.9.0 14.16 1916   2017 Update 8 Visual Studio 2017 version 15.8.0 14.15 1915   2017 Update 7 Visual Studio 2017 version 15.7.5 14.14 1914 191426433 2017 Update 7 Visual Studio 2017 version 15.7.3 14.14 1914 191426430 2017 Update 7 Visual Studio 2017 version 15.7.2 14.14 1914 191426429 2017 Update 7 Visual Studio 2017 version 15.7.1 14.14 1914 191426428 2017 Update 6 Visual Studio 2017 version 15.6.7 14.13 1913 191326132 2017 Update 6 Visual Studio 2017 version 15.6.6 14.13 1913 191326131 2017 Update 6 Visual Studio 2017 version 15.6.4 14.13 1913 191326129 2017 Update 6 Visual Studio 2017 version 15.6.3 14.13 1913 191326129 2017 Update 6 Visual Studio 2017 version 15.6.2 14.13 1913 191326128 2017 Update 6 Visual Studio 2017 version 15.6.1 14.13 1913 191326128 2017 Update 6 Visual Studio 2017 version 15.6.0 14.13 1913 191326128 2017 Update 5 Visual Studio 2017 version 15.5.7 14.12 1912 191225835 2017 Update 5 Visual Studio 2017 version 15.5.6 14.12 1912 191225835 2017 Update 5 Visual Studio 2017 version 15.5.4 14.12 1912 191225834 2017 Update 5 Visual Studio 2017 version 15.5.3 14.12 1912 191225834 2017 Update 5 Visual Studio 2017 version 15.5.2 14.12 1912 191225831 2017 Update 4 Visual Studio 2017 version 15.4.5 14.11 1911 191125547 2017 Update 4 Visual Studio 2017 version 15.4.4 14.11 1911 191125542 2017 Update 3 Visual Studio 2017 version 15.3.3 14.11 1911 191125507 2017 Update 2 Visual Studio 2017 version 15.2 14.10 1910 191025017 2017 Update 1 Visual Studio 2017 version 15.1 14.10 1910 191025017 2017 Visual Studio 2017 version 15.0 14.10 1910 191025017 2015 Update 3 Visual Studio 2015 Update 3 [14.0] 14.0 1900 190024210 2015 Update 2 Visual Studio 2015 Update 2 [14.0] 14.0 1900 190023918 2015 Update 1 Visual Studio 2015 Update 1 [14.0] 14.0 1900 190023506 2015 Visual Studio 2015 [14.0] 14.0 1900 190023026 2013 Nobemver CTP Visual Studio 2013 Nobemver CTP [12.0] 12.0 1800 180021114 2013 Update 5 Visual Studio 2013 Update 5 [12.0] 12.0 1800 180040629 2013 Update 4 Visual Studio 2013 Update 4 [12.0] 12.0 1800 180031101 2013 Update 3 Visual Studio 2013 Update 3 [12.0] 12.0 1800 180030723 2013 Update 2 Visual Studio 2013 Update 2 [12.0] 12.0 1800 180030501 2013 Update2 RC Visual Studio 2013 Update2 RC [12.0] 12.0 1800 180030324 2013 Update 1 Visual Studio 2013 Update 1 [12.0] 12.0 1800 180021005 2013 Visual Studio 2013 [12.0] 12.0 1800 180021005 2013 RC Visual Studio 2013 RC [12.0] 12.0 1800 180020827 2013 Preview Visual Studio 2013 Preview [12.0] 12.0 1800 180020617 2012 November CTP Visual Studio 2012 November CTP [11.0] 11.0 1700 170051025 2012 Update 4 Visual Studio 2012 Update 4 [11.0] 11.0 1700 170061030 2012 Update 3 Visual Studio 2012 Update 3 [11.0] 11.0 1700 170060610 2012 Update 2 Visual Studio 2012 Update 2 [11.0] 11.0 1700 170060315 2012 Update 1 Visual Studio 2012 Update 1 [11.0] 11.0 1700 170051106 2012 Visual Studio 2012 [11.0] 11.0 1700 170050727 2010 SP1 Visual Studio 2010 SP1 [10.0]Visual C++ 2010 SP1 [10.0] 10.0 1600 160040219 2010 Visual Studio 2010 [10.0]Visual C++ 2010 [10.0] 10.0 1600 160030319 2010 Beta 2 Visual Studio 2010 Beta 2 [10.0] 10.0 1600 160021003 2010 Beta 1 Visual Studio 2010 Beta 1 [10.0] 10.0 1600 160020506 2008 SP1 Visual Studio 2008 SP1 [9.0]Visual C++ 2008 SP1 [9.0] 9.0 1500 150030729 2008 Visual Studio 2008 [9.0]Visual C++ 2008 [9.0] 9.0 1500 150021022 2008 Beta 2 Visual Studio 2008 Beta 2 [9.0] 9.0 1500 150020706 2005 SP1 Visual Studio 2005 SP1 [8.0]Visual C++ 2005 SP1 [8.0] 8.0 1400 140050727 2005 Visual Studio 2005 [8.0]Visual C++ 2005 [8.0] 8.0 1400 140050320 2005 Beta 2 Visual Studio 2005 Beta 2 [8.0] 8.0 1400 140050215 2005 Beta 1 Visual Studio 2005 Beta 1 [8.0] 8.0 1400 140040607   Windows Server 2003 SP1 DDK (for AMD64)   1400 140040310 2003 SP1 Visual Studio .NET 2003 SP1 [7.1]Visual C++ .NET 2003 SP1 [7.1] 7.1 1310 13106030   Windows Server 2003 SP1 DDK   1310 13104035 2003 Visual Studio .NET 2003 [7.1]Visual C++ .NET 2003 [7.1] 7.1 1310 13103077   Visual Studio Toolkit 2003 [7.1] 7.1 1310 13103052 2003 Beta Visual Studio .NET 2003 Beta [7.1] 7.1 1310 13102292   Windows Server 2003 DDK   1310 13102179 2002 Visual Studio .NET 2002 [7.0]Visual C++ .NET 2002 [7.0] 7.0 1300 13009466   Windows XP SP1 DDK   1300 13009176 6.0 SP6 Visual Studio 6.0 SP6Visual C++ 6.0 SP6 6.0 1200 12008804 6.0 SP5 Visual Studio 6.0 SP5Visual C++ 6.0 SP5 6.0 1200 12008804   Visual Studio 97 [5.0]Visual C++ 5.0 5.0 1100     Visual C++ 4.2 4.2 1020     Visual C++ 4.1 4.1 1010     Visual C++ 4.0 4.0 1000     Visual C++ 2.0 2.0 900     Visual C++ 1.0 1.0 800     Microsoft C/C++ 7.0   700     Microsoft C 6.0   600   Visual Studio 버전 참고 : https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Version_history" }, { "title": "[ VC++ ] Windows OS 버전 체크", "url": "/posts/cpp-os-version/", "categories": "정보, 포맷", "tags": "VC++, OSVERSIONINFOEX, GetVersionEx", "date": "2022-07-18 20:00:00 +0900", "snippet": "Contents 윈도우 버전 체크윈도우 버전 체크윈도우의 버전을 얻어오는 방법은 여러가지가 있으나, GetVersion, GetVersionEx, VerifyVersionInfo 함수 등은 부정확한 버전 정보를 얻어 올 수 있어서 지양하는 것이 좋습니다. Windows 8.1 이상에서는 GetVersion, GetVersionEx 함수는 더 이상 사용할 수 없습니다. Windows 10 기준으로 VerifyVersionInfo 함수도 사용할 수 없습니다.VerifyVersionInfo 함수(Winows 2000 아래 버전는 사용 불가)는 등록 정보에서 호환성 모드를 설정한 경우에 GetVersion/GetVerionEx 함수가 페이크 값(호환성 모드에 의해 변경된 버전 정보)을 리턴하면서 원본 값을 구하기 위해서 생긴 함수였으나 윈도우 10이 출시되면서 이 함수마저 버전정보가 이상하게 나와서 사용할 수가 없습니다. 물론 아래에 설명하는 방법으로 할 경우 정상적인 정보를 얻을 수도 있습니다.아래는 MS 사이트의 원문입니다. If the application has no manifest, VerifyVersionInfo behaves as if the operation system version is Windows 8 (6.2). If the application has a manifest that contains the GUID that corresponds to Windows 8.1, VerifyVersionInfo behaves as if the operation system version is Windows 8.1 (6.3). If the application has a manifest that contains the GUID that corresponds to Windows 10, VerifyVersionInfo behaves as if the operation system version is Windows 10 (10.0).The Version Helper functions use the VerifyVersionInfo function, so the behavior IsWindows8Point1OrGreater and IsWindows10OrGreater are similarly affected by the presence and content of the manifest.요약하자면 GUID를 포함한 메니페스트가 있는 경우에만 정상적으로 버전정보를 보여주며 그렇지 않은 경우에는 문제가 발생됩니다.레지스트리의 정보를 이용하여 윈도우의 버전을 체크하는 방법에 대한 정리입니다.enum OS_INFO_TYPE{\tSZ_BUILD = 0,\t\t// Current build number\tSZ_CUR_VER,\t\t// Current version\tSZ_DSP_VER,\t\t// Display version\tSZ_ROOT,\t\t// System Root\tDW_MAJOR,\t\t// Current major version number\tDW_MINOR,\t\t// Current minor version number\tDW_UBR,\t\t\t// UBR (Update Build Revision)};namespace osi{\tconst TCHAR kBuildNumber[]\t= _T(\"CurrentBuildNumber\");\tconst TCHAR kMajorVersion[]\t= _T(\"CurrentMajorVersionNumber\");\tconst TCHAR kMinorVersion[]\t= _T(\"CurrentMinorVersionNumber\");\tconst TCHAR kVersion[]\t\t= _T(\"CurrentVersion\");\tconst TCHAR kDisplayVersion[]\t= _T(\"DisplayVersion\");\tconst TCHAR kBuildRevision[]\t= _T(\"UBR\");\tconst TCHAR kSystemRoot[]\t= _T(\"SystemRoot\");};struct OS_INFOS{\tOS_INFO_TYPE dwKey;\tconst TCHAR *pszValue;};OS_INFOS OSINF[] =\t{ {OS_INFO_TYPE::SZ_BUILD\t, osi::kBuildNumber\t}\t\t\t, {OS_INFO_TYPE::SZ_CUR_VER\t, osi::kVersion\t\t}\t\t\t, {OS_INFO_TYPE::SZ_DSP_VER\t, osi::kDisplayVersion\t}\t\t\t, {OS_INFO_TYPE::SZ_ROOT\t, osi::kSystemRoot\t}\t\t\t, {OS_INFO_TYPE::DW_MAJOR\t, osi::kMajorVersion\t}\t\t\t, {OS_INFO_TYPE::DW_MINOR\t, osi::kMinorVersion\t}\t\t\t, {OS_INFO_TYPE::DW_UBR\t\t, osi::kBuildRevision\t}};int GetWindowVersion(OS_INFO_TYPE oit){\tLONG lResult;\tHKEY hKey;\tDWORD dwType;\tDWORD dwBytes;\tDWORD dwRes = 0;\t// Open Regstry\tlResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"), 0, KEY_QUERY_VALUE, &amp;hKey);\tif (lResult != ERROR_SUCCESS)\t{\t\tgoto END;\t}\t// Read Regstry Value\tlResult = RegQueryValueEx(hKey, OSINF[oit].pszValue, 0, &amp;dwType, (LPBYTE)&amp;dwRes, &amp;dwBytes);\tif (lResult == ERROR_SUCCESS)\t{\t\tRegCloseKey(hKey);\t\treturn dwRes;\t}END:\tRegCloseKey(hKey);\treturn -1;}bool GetWindowVersion(OS_INFO_TYPE oit, TCHAR *szData, int nSize = 128){\tLONG lResult;\tHKEY hKey;\tDWORD dwType;\tDWORD dwBytes = nSize;\t// Open Regstry\tlResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"), 0, KEY_QUERY_VALUE, &amp;hKey);\tif (lResult != ERROR_SUCCESS)\t{\t\tgoto END;\t}\tTCHAR szMsg[256];\tmemset(szMsg, 0x00, sizeof(szMsg));\t_stprintf(szMsg, _T(\"Key : %s\\r\\n\"), OSINF[oit].pszValue);\tOutputDebugString(szMsg);\t// Read Regstry Value\tlResult = RegQueryValueEx(hKey, OSINF[oit].pszValue, 0, &amp;dwType, (LPBYTE)szData, &amp;dwBytes);\tif (lResult == ERROR_SUCCESS)\t{\t\treturn true;\t}END:\tRegCloseKey(hKey);\treturn false;}..[중략]...// 사용법int _tmain(int argc, _TCHAR *argv[]){\tTCHAR szCurVer[128];\tTCHAR szDspVer[128];\tTCHAR szBuildVer[128];\tTCHAR szRoot[256];\tint nMajor = 0;\tint nMinor = 0;\tint nUbrvs = 0;\tbool bRet = false;\tmemset(szCurVer, 0x00, sizeof(szCurVer));\tmemset(szDspVer, 0x00, sizeof(szDspVer));\tmemset(szBuildVer, 0x00, sizeof(szBuildVer));\tmemset(szRoot, 0x00, sizeof(szRoot));\tbRet = GetWindowVersion(OS_INFO_TYPE::SZ_CUR_VER, szCurVer, sizeof(szCurVer));\tbRet = GetWindowVersion(OS_INFO_TYPE::SZ_DSP_VER, szDspVer, sizeof(szDspVer));\tbRet = GetWindowVersion(OS_INFO_TYPE::SZ_BUILD, szBuildVer, sizeof(szBuildVer));\tbRet = GetWindowVersion(OS_INFO_TYPE::SZ_ROOT, szRoot, sizeof(szRoot));\tnMajor = GetWindowVersion(OS_INFO_TYPE::DW_MAJOR);\tnMinor = GetWindowVersion(OS_INFO_TYPE::DW_MINOR);\tnUbrvs = GetWindowVersion(OS_INFO_TYPE::DW_UBR);\tTCHAR szMsg[2048];\tmemset(szMsg, 0x00, sizeof(szMsg));\t_stprintf(szMsg, _T(\"Version : Windows %ld.%ld(%ld)\\r\\nCurrentVersion : %s\\r\\n\") \\\t\t_T(\"DisplayVersion : %s\\r\\nBuildVersion : %s\\r\\nRoot : %s\\r\\n\")\t\t, nMajor, nMinor, nUbrvs, szCurVer, szDspVer, szBuildVer, szRoot);\tAfxMessageBox(szMsg);} “콘솔의 버전 정보 이용” 참고 : https://neodreamer-dev.tistory.com/795 운영체제 버전 Major Minor 기타 Windows 11 10.0 10 0 OSVERSIONINFOEX.dwBuildNumber &gt;= 220000 Windows 10 10.0 10 0 OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION Windows Server 2016 10.0 10 0 OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION Windows 8.1 6.3 6 3 OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION Windows Server 2012 R2 6.3 6 3 OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION Windows 8 6.2 6 2 OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION Windows Server 2012 6.2 6 2 OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION Windows 7 6.1 6 1 OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION Windows Server 2008 R2 6.1 6 1 OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION Windows Server 2008 6.0 6 0 OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION Windows Vista 6.0 6 0 OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION Windows Server 2003 R2 5.2 5 2 GetSystemMetrics(SM_SERVERR2) != 0 Windows Home Server 5.2 5 2 OSVERSIONINFOEX.wSuiteMask &amp; VER_SUITE_WH_SERVER Windows Server 2003 5.2 5 2 GetSystemMetrics(SM_SERVERR2) == 0 Windows XP Professionalx64 Edition 5.2 5 2 (OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION)SYSTEM_INFO.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64 Windows XP 5.1 5 1 Not applicable Windows 2000 5.0 5 0 Not applicable " }, { "title": "[ Error ] Visual Studio C++ Error 해결 방법", "url": "/posts/err-vcpp-solved/", "categories": "정보, 에러", "tags": "Error, solved", "date": "2022-07-15 06:00:00 +0900", "snippet": "Contents ISO C++ 오류 C2760 C2850 C4996 E0167 LNK2026 LNK4022 LNK4070 MIDL2311ISO C++ 오류 error : &lt;LanguageStandard&gt; 요소에 잘못된 값 “stdcpp20”이(가) 있습니다 해결방법 : 프로젝트 &gt; 속성 &gt; 구성 속성 &gt; C/C++ &gt; 언어 탭에서 C++ 언어 표준을 ISO C++ 최신 초안 표준(/std:c++latest)로 선택하면 해결이 됩니다. 이렇게 하면 현 Visual Studio에서 사용하고 있는 가장 최근의 C++ 표준 라이브러리를 사용할 수 있게 됩니다.C2760 구문 오류: ‘식별자’은(는) 예기치 않은 토큰입니다. 필요한 토큰은 ‘형식 지정자’입니다. 해결방법 : 프로젝트 &gt; 속성 &gt; 구성 속성 &gt; C/C++ &gt; 언어 탭에서 준수 모드(Conformance mode)를 아니오(No)로 선택하면 해결이 됩니다.C2850 ‘PCH 헤더 파일’: 파일 범위에서만 사용할 수 있습니다. 중첩된 구문에는 사용할 수 없습니다. 추가 메시지 : PCH 경고: 전역 범위에 헤더 중지가 있어야 합니다. IntelliSense PCH 파일이 생성되지 않았습니다. 해결방법 : stdafx.h 또는 pch.h파일의 선언 중 세미콜론(;)이 빠져 있는지 확인합니다.(예를 들면 구조체, 배열 등 선언후 세미콜론이 올바르게 사용되었나 확인합니다.)C4996 ‘GetVersionExW’: deprecated로 선언되었습니다. 해결방법 : 프로젝트 &gt; 속성 &gt; 구성 속성 &gt; C/C++ &gt; 전처리기 탭에서 전처리기 정의에 _CRT_SECURE_NO_DEPRECATE을 추가하거나 소스코드에 #progma warning(disable:4996)을 선언하면 됩니다.E0167 const char * 형식의 인수가 char * 형식의 매개 변수와 호환되지 않습니다 해결방법 : 프로젝트 &gt; 속성 &gt; 구성 속성 &gt; C/C++ &gt; 언어 탭에서 준수 모드를 아니요로 변경하여 주면 됩니다. 다른 방법으로 변수를 타입캐스팅 해주셔도 상관없습니다만 많은 경우엔 설정으로 간단히 해결하시는것이 더 빠를 수 있습니다.LNK2026 LNK2026: 모듈이 SAFESEH 이미지에 대해 안전하지 않습니다. 해결방법 : 프로젝트 &gt; 속성 &gt; 구성 속성 &gt; 링커 &gt; 고급 탭에서 이미지에 안전한 예외 처리기 포함을 아니요(/SAFESEH:NO)로 선택하면 해결이 됩니다.LNK4022 LNK4022: ‘xxx’ 기호에만 일치하는 것을 찾을 수 없습니다. 해결방법 : xxx 함수가 사용하는 라이브러리(예 MFC 라이브러리 등) 중에도 존재하는 경우 발생되는 오류입니다. 예를 들면 GetResult가 MFC의 기본라이브러리에도 존재한다고 가정하면, 소스상에 GetResult라는 함수를 재정의하면 문제가 발생됩니다. 이 경우 함수명을 다른 이름으로 바꾸어주면 문제가 해결됩니다.LNK4070 warning LNK4070: /OUT: .EXP의 xxx.dll 지시문이 ‘~yyy.dll’ 출력 파일 이름과 다릅니다. 지시문이 무시됩니다. 해결방법 : .def 파일의 LIBRARY : “xxx”를 LIBRARY : “yyy”로 변경해주면 해결됩니다.MIDL2311 error MIDL2311: statements outside library block are illegal in mktyplib compatability mode : [ ] 해결방법 : 이전의 ocx 소스 코드를 불러 올 경우 odl 파일에서 #include 헤더 구문이 library 바깥에 위치하면 해당 오류가 발생됩니다. #include 헤더 구문을 library 안쪽으로 이동시키면 해결이 됩니다.#include &lt;olectl.h&gt;#include &lt;idispids.h&gt;[ uuid(18C89C39-B40A-410B-9659-064000FCCCDB), version(1.0), helpfile(\"Avata.hlp\"), helpstring(\"Avata ActiveX Control module\"), control ]library AVATALib{...[생략]...에서[ uuid(18C89C39-B40A-410B-9659-064000FCCCDB), version(1.0), helpfile(\"Avata.hlp\"), helpstring(\"Avata ActiveX Control module\"), control ]library AVATALib{\t#include &lt;olectl.h&gt;\t#include &lt;idispids.h&gt;...[생략]...으로 #include의 위치를 이동시키면 됩니다." }, { "title": "[ Format ] 커서(Cursor; .cur)", "url": "/posts/fmt-cursor/", "categories": "정보, 포맷", "tags": "Format, cur, cursor, .cur", "date": "2022-07-07 00:00:00 +0900", "snippet": "Contents 기본 정보 기본 파일 포맷기본 정보최초의 CUR 파일 형식은 1981년 Microsoft의 Windows 1.0 운영 체제에 적용되었으며, 윈도우95부터는 애니메이션이 가능한 .ani 파일도 사용이 가능해졌습니다. .cur 파일은 .ico 파일과 동일하게 정적인 이미지이며, 두 파일 모두 Device-Independent Bitmap DIB (Device-Independent Bitmap) 스펙을 기반으로 만들어집니다. 참고로 .cur 과 .ico 파일은 하나의 파일에 한개 이상의 이미지 파일을 포함할 수 있습니다.기본 파일 포맷 Name size Description Reserved 2 byte 항상 0 Type 2byte 항상 2 (*참고 : ico는 1) Count 2byte 파일안에 커서의 갯수 Entries Count * 2byte 커서들의 리스트     Width 1byte 커서의 넓이     Height 1byte 커서의 높이     ColorCount 1byte = 0 !     Reserved 1byte 항상 0     XHotspot 2byte 핫스팟(클릭)의 X 좌표     YHotspot 2byte 핫스팟(클릭)의 Y 좌표     SizeInBytes 4byte 크기(InfoHeader + ANDBitmap + XORBitmap)     FileOffset 4byte InfoHeader의 시작 위치   갯수 만큼 반복     InfoHeader 40 byte Variant of BMP InfoHeader     Size 4byte InfoHeader 구조체 사이즈(항상 40)     Width 4byte 커서 넓이     Height 4byte 커서 높이 (XORbitmap와 ANDbitmap의 높이도 더함)     Planes 2byte planes의 수(항상 1)     BitCount 2byte 픽셀당 비트수(항상 1)     Compression 4byte 압축 타입(항상 0)     ImageSize 4byte 픽셀의 갯수(Byte 안의 이미지 크기) = 0 (uncompressed)     XpixelsPerM 4byte 사용하지 않음(0)     YpixelsPerM 4byte 사용하지 않음(0)     ColorsUsed 4byte 사용하지 않음(0)     ColorsImportant 4byte 사용하지 않음(0) Colors 8 byte 픽셀당 비트수가 항상 1이므로 항상 2개의 항목을 가짐.     Color 0 R 1byte 배경 R = 0     Color 0 G 1byte 배경 G = 0     Color 0 B 1byte 배경 B = 0     reserved 1byte 항상 0     Color 1 R 1byte 전경 R = 255     Color 1 G 1byte 전경 G = 255     Color 1 B 1byte 전경 B = 255     reserved 1byte 항상 0 XORbitmap   ‘래스터 데이터 인코딩’ 참고 ANDbitmap   ‘래스터 데이터 인코딩’ 참고 래스터 데이터 인코딩(Raster Data encoding)픽셀은 흑백 BMP와 같은 방식으로 아래에서 위, 왼쪽에서 오른쪽으로 저장됩니다. 픽셀 라인은 32비트(4바이트) 내에서 0으로 채워집니다. 모든 라인은 동일한 바이트 수를 갖습니다. 모든 바이트는 8개의 픽셀을 갖으며, 최상위 비트는 그 중 가장 왼쪽에 있는 픽셀을 나타냅니다. 최대 32비트 경계까지 0으로 채우는 것을 기억하십시오(최대 31개까지 픽셀에 0이 채워질 수 있습니다.). 비록 2개의 색상 테이블이 있지만 Windows는 이를 무시하는 것 같습니다. Windows가 스크린에 커서를 그릴 때마다 ANDbitmap이 적용됩니다. 그 이후에 XORBitmap이 적용됩니다. 두 비트맵 모두 흑백 BMP와 동일한 방식으로 인코딩됩니다. 파일에 둘 이상의 커서가 있는 경우 Windows는 시스템 설정과 일치하는 커서를 사용합니다. AND XOR 결과 0 0 검은색 픽셀 0 1 흰색 픽셀 1 0 투명한 배경 픽셀 1 1 반전된 배경 픽셀 Structurenamespace cur_file{#pragma pack(push,1)\ttypedef struct _CURSOR_ENTRIES\t{\t\tunsigned char width;\t\tunsigned char height;\t\tunsigned char color_count;\t\tunsigned char reserved = 0;\t\tunsigned short x_hotspot;\t\tunsigned short y_hotspot;\t\tunsigned int size_in_bytes;\t\tunsigned int file_offset;\t} CURSOR_ENTRIES;\ttypedef struct _CURSOR_INFO_HEADER\t{\t\tunsigned int size = 40;\t\tunsigned int width;\t\tunsigned int height;\t\tunsigned short planes = 1;\t\tunsigned short bit_count = 1;\t\tunsigned int compression = 0;\t\tunsigned int image_size = 0;\t/* uncompressed */\t\tunsigned int x_pixels_per_M = 0;\t\tunsigned int y_pixels_per_M = 0;\t\tunsigned int colors_used = 0;\t\tunsigned int colors_important = 0;\t} CURSOR_INFO_HEADER;\ttypedef struct _CURSOR_HEADER\t{\t\tshort reserved = 0;\t\t/* type ==&gt; ico : 1, cur : 2 */\t\tshort type = 2;\t\tshort count;\t\tCURSOR_ENTRIES entires;\t\tCURSOR_INFO_HEADER info_header;\t};#pragma pack(pop)} 참고 https://www.daubnet.com/en/file-format-cur https://www.daubnet.com/en/file-format-ico" }, { "title": "[ VC++ ] 문자열 인코딩 변환 매크로 주의 사항(W2A, A2W, T2A, A2T)", "url": "/posts/cpp-macro-string-encoding/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, macro, encoding, string", "date": "2022-06-29 00:00:00 +0900", "snippet": "Contents 문자열 인코딩 변환 매크로 사용시 주의 ALT 3.0과 ATL 7.0 차이 비교문자열 인코딩 변환 매크로 사용시 주의유니코드(Unicode)와 아스키(Ascii) 상호간 문자열을 변활할때 ATL3.0에서 제공하는 문자열 변환 매크로를 많이 사용하게 되는데, W2A, A2W, T2A, A2T의 경우 반복문에서 사용을 하게 되면 스택오버플로우(Stack overflow)가 발생하게되어 문자열이 종종 깨지게 됩니다. 이는 W2A, T2A, A2W, A2T가 변환 과정에서 내부 스택을 사용하여 변환하기 때문에 발생이 됩니다. ATL7.0에서는 이를 개선하기 위해 CW2A, CA2W, CW2CA, CA2CW, CT2A, CA2T, CT2CA, CA2CT를 제공하는데, 이를 이용하는 것이 좋습니다. 이는 내부에 128 바이트의 버퍼를 가지고 있고 이를 넘어서는 경우에는 힙에 메모리를 할당하여 반복문안에 사용하더라도 스택오버플로우가 발생되지 않는다고 합니다.ALT 3.0과 ATL 7.0 차이 비교 기존 ATL 3.0 매크로 변환 새로운 ATL 7.0 변환 클래스 스택에 메모리를 할당. 작은 문자열은 스택, 큰 문자열은 힙에 메모리 할당. 문자열은 함수가 종료 될 때 해제. 문자열은 변수가 범위를 벗어날 때 해제. 예외 처리기에서 사용할 수 없음. 예외 처리기에서 사용할 수 있음. 반복문에 사용하기가 적합하지 않음.함수가 종료될 때까지 메모리 사용이 증가함. 반복문에 사용 가능.반복문 내에서 반복될 때 메모리가 해제됨. 큰 문자열에 대한 문제 발생.(스택 공간에 제한적) 큰 문자열에도 문제가 없음. 보통 USES_CONVERSION 정의가 필요. USES_CONVERSION 정의가 필요 없음. OLE의 의미가 OLE2ANSI 정의에 따라 달라짐. OLE는 W로 항상 동일. " }, { "title": "[ VC++ ] 콘솔 프로그램 실행 후 출력 메시지 갈무리", "url": "/posts/cpp-console-capture/", "categories": "프로그래밍, C++ (CPP)", "tags": "VC++, console, redirection, capture", "date": "2022-06-28 13:52:00 +0900", "snippet": "Contents 콘솔 프로그램 출력 메시지 갈무리콘솔 프로그램 출력 메시지 갈무리어플리케이션에서 콘솔 프로그램의 출력된 메시지를 갈무리(Console redirection) 하는 방법에 대한 정리입니다. 콘솔창의 메시지 갈무리를 위해서는 CreateProcess와 CreatePipe 함수를 이용하며 아래의 내용에 유의 하여야 합니다. dwFlags에 STARTF_USESTDHANDLES을 지정. 사용자에 의해 지정된 핸들(hStdInput, hStdOutput, hStdError)을 사용. 지정하지 않을 경우 표준 출력의 기본 값인 콘솔 창에 출력. hStdOutput에 모니터링에 사용할 핸들 지정. hStdError는 오류 모니터링에 사용할 핸들 지정.#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#define PEEK_NAMED_PIPETCHAR APP[] = _T(\"C:\\\\Windows\\\\System32\\\\NETSTAT.EXE\");int _tmain(int argc, _TCHAR *argv[]) {\tTCHAR szMsgW[256];\tchar szMsg[256];\tchar szBuff[256];\tDWORD dwRead = 0, dwOut = 0, dwErr = 0;\tHANDLE hStdOutWrite = NULL, hStdOutRead = NULL;#ifdef PEEK_NAMED_PIPE\tHANDLE hStdErrWrite = NULL, hStdErrRead = NULL;#endif\tSTARTUPINFO si;\tSECURITY_ATTRIBUTES sa;\tPROCESS_INFORMATION pi;\tsa.nLength = sizeof(SECURITY_ATTRIBUTES);\tsa.lpSecurityDescriptor = NULL;\tsa.bInheritHandle = TRUE;\tHANDLE hReadPipe;\tCreatePipe(&amp;hStdOutRead, &amp;hStdOutWrite, &amp;sa, 0); // 콘솔에 출력되는 정보와 연결할 파이프 생성#ifdef PEEK_NAMED_PIPE\tCreatePipe(&amp;hStdErrRead, &amp;hStdErrWrite, &amp;sa, 0); // 콘솔에 출력되는 오류와 연결할 파이프 생성#endif\tZeroMemory(&amp;si, sizeof(STARTUPINFO));\tsi.cb = sizeof(STARTUPINFO);\tsi.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\tsi.hStdInput = NULL;\tsi.hStdOutput = hStdOutWrite;#ifdef PEEK_NAMED_PIPE\tsi.hStdError = hStdErrWrite;#else\tsi.hStdError = hStdOutWrite;#endif\tsi.wShowWindow = SW_HIDE;\tif (!CreateProcess(NULL, APP, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi))\t{\t\tmemset(szMsg, 0x00, sizeof(szMsg));\t\tsprintf(szMsg, \"LastError : %ld\", GetLastError());\t\tOutputDebugStringA(szMsg);\t}\tCloseHandle(pi.hThread);#ifdef PEEK_NAMED_PIPE\twhile (PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &amp;dwOut, NULL) ||\t\tPeekNamedPipe(hStdErrRead, NULL, 0, NULL, &amp;dwErr, NULL)) // 읽을 데이터가 있는지 체크\t{\t\tif (dwOut &lt;= 0 &amp;&amp; dwErr &lt;= 0 &amp;&amp; WaitForSingleObject(pi.hProcess, 0) != WAIT_TIMEOUT)\t\t\tbreak; // 콘솔 프로그램이 종료된 경우 loop를 빠져나간다.\t\twhile (PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &amp;dwOut, NULL) &amp;&amp; dwOut &gt; 0)\t\t{\t\t\tmemset(szBuff, 0x00, sizeof(szBuff));\t\t\tReadFile(hStdOutRead, szBuff, sizeof(szBuff), &amp;dwRead, NULL);\t\t\tszBuff[dwRead] = 0;\t\t\tmemset(szMsg, 0x00, sizeof(szMsg));\t\t\tsprintf(szMsg, \"&gt;&gt;[R] %s\", szBuff);\t\t\tOutputDebugStringA(szMsg);\t\t}\t\twhile (PeekNamedPipe(hStdErrRead, NULL, 0, NULL, &amp;dwErr, NULL) &amp;&amp; dwErr &gt; 0)\t\t{\t\t\tmemset(szBuff, 0x00, sizeof(szBuff));\t\t\tReadFile(hStdErrRead, szBuff, sizeof(szBuff), &amp;dwRead, NULL);\t\t\tszBuff[dwRead] = 0;\t\t\tmemset(szMsg, 0x00, sizeof(szMsg));\t\t\tsprintf(szMsg, \"&gt;&gt;[E] %s\", szBuff);\t\t\tOutputDebugStringA(szMsg);\t\t}\t}#else\tchar buf[128];\tCString strOutput, strTemp;\tBOOL result;\tdo\t{\t\tmemset(buf, 0x00, sizeof(buf));\t\tresult = ::ReadFile(hStdOutRead, buf, sizeof(buf), &amp;dwRead, 0);\t\tmemset(szMsgW, 0x00, sizeof(szMsgW));\t\tTCHAR *pBuff = CA2CT(buf);\t\t_stprintf(szMsgW, _T(\"&gt;&gt;[O] %s\"), (TCHAR *)CA2CT(buf));\t\tOutputDebugString(szMsgW);\t\tstrTemp = CA2CT(buf);\t\tstrOutput += strTemp.Left(dwRead);\t} while (result);\tmemset(szMsgW, 0x00, sizeof(szMsgW));\t_stprintf(szMsgW, _T(\"&gt;&gt;[T] %s\"), strOutput);\tOutputDebugString(szMsgW);#endif\tCloseHandle(pi.hProcess);\tCloseHandle(hStdOutRead);\tCloseHandle(hStdOutWrite);#ifdef PEEK_NAMED_PIPE\tCloseHandle(hStdErrRead);\tCloseHandle(hStdErrWrite);#endif\treturn 0;}" }, { "title": "메일보관함(웹) 클라이언트", "url": "/posts/naonsoft-008/", "categories": "", "tags": "", "date": "2022-02-01 09:00:00 +0900", "snippet": "메일보관함(웹) 클라이언트 기간 : 2022.02 ~ 2022.04■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ 메일보관함은 그룹웨어의 메일을 로컬PC에 백업하여 관리할 수 있는 프로그램입니다. UI 구성은 그룹웨어에서 하며, 네이티브 프로그램에서는 트레이 아이콘 외의 화면은 별도로 존재하지 않습니다." }, { "title": "PC와 모바일 간의 클립보드 공유", "url": "/posts/naonsoft-007/", "categories": "", "tags": "", "date": "2021-03-01 09:00:00 +0900", "snippet": "PC와 모바일 간의 클립보드 공유 기간 : 2021.03 ~ 2021.04■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, C# 클립보드는 나온톡 서버를 이용하여 클립보드 내용을 관리하거나 타 기기(모바일, PC 등)와 클립보드 내용을 공유할 수 있으며, 윈도우의 클립보드를 관리할 수 있는 프로그램입니다." }, { "title": "독립실행형 한글실행기", "url": "/posts/naonsoft-006/", "categories": "", "tags": "", "date": "2020-10-01 09:00:00 +0900", "snippet": "독립실행형 한글실행기 기간 : 2020.10 ~ 2020.11전자결제(공공)■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, C# 한글 ActiveX를 이용하여 문서를 편집할 수 있는 툴을 제공. 한글과 컴퓨터에서 한글(HWP) OCX컨트롤을 보안상 문제로 2023년 12월 31일 서비스 종료됨." }, { "title": "(New)아웃룩싱크", "url": "/posts/naonsoft-005/", "categories": "", "tags": "", "date": "2020-07-01 09:00:00 +0900", "snippet": "(New)아웃룩싱크 기간 : 2020.07 ~ 2020.12Outlook Addin 프로그램■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, C# 아웃룩싱크는 그룹웨어의 일정/할일을 로컬PC에 설치된 Outlook의 일정/할일과 동기화 시켜주는 프로그램입니다. 또한 메일 작성시 그룹웨어와 연동하여 조직도를 보여주며, 받는사람, 참고, 숨은참조 등에 조직도내 부서와 사용자를 추가할 수 있습니다." }, { "title": "나온서비스 개발 및 서비스 개발에 따른 툴박스 기능 수정", "url": "/posts/naonsoft-004/", "categories": "", "tags": "", "date": "2019-11-01 09:00:00 +0900", "snippet": "나온서비스 개발 및 서비스 개발에 따른 툴박스 기능 수정 기간 : 2019.11 ~ 2020.03■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ 나온서비스 프로그램은 윈도우의 서비스 등록 프로그램으로 윈도우 시작시 System에 의해 서비스가 구동 됩니다. 이 서비스 프로그램은 웹소켓 서버로서 브라우저나 어플리케이션에서 접속하여 정의된 패킷을 주고 받을 수 있도록 설계되어 있습니다. 그리고 설치 후 실행시 방화벽 설정에서 해당 프로그램으로의 인바운드(Inbound)는 모두 허용하도록 자동 설정합니다.(사용자가 인위적으로 인바운드를 막더라도 프로그램 실행시 체크하여 인바운드를 다시 오픈하도록 개발이 되어 있습니다.)" }, { "title": "ToolBox 개발", "url": "/posts/naonsoft-003/", "categories": "", "tags": "", "date": "2017-08-01 09:00:00 +0900", "snippet": "ToolBox 개발 기간 : 2017.08 ~ 2018.02툴박스에는 웹메신저의 알림, 캡쳐, 원격, 로컬프로그램 실행(URL Scheme) 등을 지원하는 프로그램 및 나온톡이 포함되어 있음.■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ URL Scheme (NaonProtocol) (7.0.43.54 이전 버전에만 적용) 알림 (NaonNotice) 에이전트 (NaonAgent) (7.0.43.54 이전 버전에만 적용) 원격지원 (NaonRsp) 화면캡쳐 (NaonCapture) 나온서비스 (NaonService) 프로그램 실행(NaonExec) 브라우저 실행(NaonCubro) 오피스 플러그인 (NaonOfficePlugin) (7.0.60.0 버전 이후부터 적용) 클립보드 (NaonClipboard) 메일 보관함 (NaonWebMailBox) (7.3.0.0 버전 이후부터 적용) 한글 비교 (NaonHwpCompare)" }, { "title": "뉴메신저 개발", "url": "/posts/naonsoft-002/", "categories": "", "tags": "", "date": "2016-09-01 09:00:00 +0900", "snippet": "뉴메신저 개발 기간 : 2016.09 ~ 2017.08■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, C# " }, { "title": "메신저 및 패키지 유지보수/개발", "url": "/posts/naonsoft-001/", "categories": "", "tags": "", "date": "2013-09-01 09:00:00 +0900", "snippet": "메신저 및 패키지 유지보수/개발 기간 : 2013.09 ~ 현재■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, C# " }, { "title": "eBook(ePub) Reader", "url": "/posts/RHKorea-001/", "categories": "", "tags": "", "date": "2012-11-01 09:00:00 +0900", "snippet": "eBook(ePub) Reader 기간 : 2012.11 ~ 2013.06■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ Webkit을 이용한 DRM이 적용된 컨텐츠용 eBook Reader 프로그램 개발." }, { "title": "중소기업 연수원 모바일러닝", "url": "/posts/wizi-003/", "categories": "", "tags": "", "date": "2012-06-01 09:00:00 +0900", "snippet": "중소기업 연수원 모바일러닝 기간 : 2012.06 ~ 2012.10■ 사용 기술 역활 : 임베디드SW개발 시스템 환경 : iOS 사용 기술 : Objective-C 모바일 전환대상 서비스들을 모바일 플랫폼에 맞추어 재가공하여 e-러닝 모바일 시스템 구축 e-러닝 웹사이트 메뉴 구성 중 회원정보, 공지사항, 강의안내, 강의수강 등 기존 서비스의 모바일 전환 구축" }, { "title": "네트워크 기반의 U-Devices 및 Robot을 이용한 개인별 맞춤학습 관리 기술", "url": "/posts/wizi-002/", "categories": "", "tags": "", "date": "2010-10-02 09:00:00 +0900", "snippet": "CE향 결제 시스템 개발 기간 : 2010.10 ~ 2012.06 정부과제(지식경제부)■ 사용 기술 역활 : 응용SW개발/임베디드SW개발 시스템 환경 : Windows, iOS 사용 기술 : C++, Objective-C 「지식서비스USN산업원천기술개발사업」 참여기관 : 크레듀, SDA에듀, 정보통신산업진흥원, 한국이러닝산업협회 1.「스마트러닝 학습관리에이전트」는 스마트러닝 과 u-러닝을 충실히 지원하는 u-Device 즉, 스마트폰, 태블릿pc 등 스마트기기에서 학습이 가능한 앱 기반 학습관리에이전트로서 온/오프라인 학습, 및 출석, 진도 등의 학습정보를 통합 LMS서버와의 동기화를 비롯한 모든 학습관리를 스마트기기상에서 구현하였으며 국제표준화가 진행되고 있는 IMS LD(Learning Design)를 적용하여 개발한 시스템으로서 국내에서는 최초이며, 세계에서도 상용화 시도는 거의 최초로 할 수 있음. 2.「IMS Basic LTI 1.0 시스템 및 협력학습시스템」은 IMS Working Group에서 현재 국제표준으로서 추진되고 있는 LTI(Learning Tools Interoperability)기술로서 다양한 학습지원 도구를 Tool Provider 라고 하는 곳에서 지원하여 LMS에 없는 학습도구라도 언제든지 사용할 수 있게끔 하는 학습지원도구 공유 및 결과물 공유가 가능한 학습시스템 이며, 본 LTI 시스템에 적용 가능한 협력학습 시스템 및 도구로서는 토론, 포럼이 가능한 채팅과 실시간 협력토론이 가능한 화이트보드 등이 있으며 이외에도 다양한 학습지원이 가능한 학습도구 및 시스템을 사용할 수 있는 기술임." }, { "title": "모바일 스마트 러닝 서비스 개발", "url": "/posts/wizi-001/", "categories": "", "tags": "", "date": "2010-10-01 09:00:00 +0900", "snippet": "모바일 스마트 러닝 서비스 개발 기간 : 2010.10 ~ 2011.062010년 중소기업 서비스연구개발사업■ 사용 기술 역활 : 응용SW개발/임베디드SW개발 시스템 환경 : Windows, iOS, WinCE, x86 사용 기술 : C++, Objective-C, EVC (Embedded Visual C++) 학습자가 PC와 모바일 기기를 통해 학습한 학습이력 자료 상호 동기화 미들웨어 개발 스마트폰 상에서 무선 인터넷 연결 없이도 콘텐츠를 학습할 수 있는 모바일 러닝 어플리케이션 개발 무선네트워크 연결 시 학습이력 정보가 전송되어 동기화 되는 모바일용 학습관리지원 도구 개발" }, { "title": "CE향 결제 시스템 개발", "url": "/posts/symtra-006/", "categories": "", "tags": "", "date": "2010-05-01 09:00:00 +0900", "snippet": "CE향 결제 시스템 개발 기간 : 2008.02 ~ 2008.04삼성전자■ 사용 기술 역활 : 응용SW개발 시스템 환경 : WinCE 사용 기술 : EVC (Embedded Visual C++) 냉장고 Embedded PC(P1)의 결제창을 통해 물건을 구매하는 결제용 앱 개발." }, { "title": "고려대 스마트카드 시스템 구축", "url": "/posts/symtra-005/", "categories": "", "tags": "", "date": "2010-02-01 09:00:00 +0900", "snippet": "고려대 스마트카드 시스템 구축 기간 : 2010.02 ~ 2010.08■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ RF-ID, Mifare, IC 등을 이용하여 대학내 카드 시스템 구축(출결, 결재 등)" }, { "title": "항공대 U-Campus 시스템 구축", "url": "/posts/symtra-004/", "categories": "", "tags": "", "date": "2009-07-01 09:00:00 +0900", "snippet": "항공대 U-Campus 시스템 구축 기간 : 2009.07 ~ 2010.02PM/개발■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ RF-ID, Mifare, IC 등을 이용하여 대학내 카드 시스템 구축(출결, 결재 등)" }, { "title": "연세대 U-Campus System/서울여대 전자출결 시스템 개발", "url": "/posts/symtra-003/", "categories": "", "tags": "", "date": "2009-03-01 09:00:00 +0900", "snippet": "연세대 U-Campus System/서울여대 전자출결 시스템 개발 기간 : 2009.03 ~ 2009.06■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++, EVC (Embedded Visual C++) RF-ID, Mifare, IC 등을 이용하여 대학내 카드 시스템 구축(출결, 결재 등)" }, { "title": "서울대 S-Card System", "url": "/posts/symtra-002/", "categories": "", "tags": "", "date": "2008-09-01 09:00:00 +0900", "snippet": "서울대 S-Card System 기간 : 2008.09 ~ 2009.02■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ RF-ID, Mifare, IC 등을 이용하여 대학내 카드 시스템 구축(출결, 결재 등)" }, { "title": "연세대 U-Campus System", "url": "/posts/symtra-001/", "categories": "", "tags": "", "date": "2008-05-01 09:00:00 +0900", "snippet": "연세대 U-Campus System 기간 : 2008.05 ~ 2008.09■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ RF-ID, Mifare, IC 등을 이용하여 대학내 카드 시스템 구축(출결, 결재 등)" }, { "title": "사내 인트라넷 및 메신저 개발", "url": "/posts/xobis-002/", "categories": "", "tags": "", "date": "2008-02-01 09:00:00 +0900", "snippet": "사내 인트라넷 및 메신저 개발 기간 : 2008.02 ~ 2008.04■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows, MYSQL, Apache 사용 기술 : C++, PHP " }, { "title": "얼굴인식 라이브러리/인터렉티브 시스템", "url": "/posts/xobis-001/", "categories": "", "tags": "", "date": "2007-09-01 09:00:00 +0900", "snippet": "얼굴인식 라이브러리/인터렉티브 시스템 기간 : 2007.09 ~ 2008.01■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ OpenCV를 이용하여 얼굴을 인식하는 라이브러리 개발." }, { "title": "Combi Messenger 개발", "url": "/posts/ultari-003/", "categories": "", "tags": "", "date": "2007-07-01 09:00:00 +0900", "snippet": "Combi Messenger 개발 기간 : 2007.07 ~ 2007.09■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows, Linux 사용 기술 : C++, JAVA " }, { "title": "알리미(통합 알림 서비스)", "url": "/posts/ultari-002/", "categories": "", "tags": "", "date": "2007-01-01 09:00:00 +0900", "snippet": "알리미(통합 알림 서비스) 기간 : 2007.01 ~ 2007.06서울시청(파견)■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows, Unix, IBM, Tomcat 사용 기술 : C++, JAVA 개발 목적 : Legacy system에서 개개인에게 필요한 정보를 입력하게 되면, 수시로 그 정보를 필요로 하는 개인에게 전달해 줄 필요가 있다. 이를 위해 선수과제로 Legacy system과의 연동을 위한 통합 API를 개발하고, 기존 알리미 서비스와의 호환성을 유지하면서 전자문서나 메일 등의 기존 시스템에 안정적인 서비스를 제공한다. 기대 효과 : 메일 또는 전자문서 등의 도착을 알림으로써 좀 더 빠르게 정보 전달을 할 수 있고, 그 정보에 대한 응답 회신 시간을 단축시킬 수 있다. " }, { "title": "기업용 메신저", "url": "/posts/ultari-001/", "categories": "", "tags": "", "date": "2006-08-01 09:00:00 +0900", "snippet": "기업용 메신저 기간 : 2006.08 ~ 2006.12■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ " }, { "title": "증권전용 PDA 프로그램", "url": "/posts/infobank-001/", "categories": "", "tags": "", "date": "2006-03-01 09:00:00 +0900", "snippet": "증권전용 PDA 프로그램 기간 : 2006.03 ~ 2006.08■ 사용 기술 역활 : 임베디드SW개발 시스템 환경 : WinCE 사용 기술 : EVC (Embedded Visual C++) " }, { "title": "범용 OCR Parsing 라이브러리 개발", "url": "/posts/moduinfo-002/", "categories": "", "tags": "", "date": "2005-10-01 09:00:00 +0900", "snippet": "범용 OCR Parsing 라이브러리 개발 기간 : 2005.10 ~ 2006.02농협전산분사(파견)■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows 사용 기술 : C++ " }, { "title": "통합POS 운영/개발", "url": "/posts/moduinfo-001/", "categories": "", "tags": "", "date": "2004-04-01 09:00:00 +0900", "snippet": "통합POS 운영/개발 기간 : 2004.04 ~ 2005.09농협전산분사(파견)■ 사용 기술 역활 : 응용SW개발 시스템 환경 : WinCE 사용 기술 : EVC (Embedded Visual C++) 농협전산정보분사 매입/수발주/매출 을 관리하는 PDA 프로그램(JT PDA) 개발. (Intermec, Symbol 단말기용)" }, { "title": "DBMS Client 프로그램 개발", "url": "/posts/kynax-005/", "categories": "", "tags": "", "date": "2003-09-01 09:00:00 +0900", "snippet": "DBMS Client 프로그램 개발 기간 : 2003.09 ~ 2004.03■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows, Oracle 사용 기술 : C++ 주요 업무 내용. CP(컨텐츠 프로바이더) 관리. 엑셀 파일을 분석하여 DB에 데이터 저장/수정/삭제. Oracle 서버의 CPU, 메모리 상태 관리. (차트 표시 및 알림) 각종 DB와 관련한 Query 수행." }, { "title": "홈 네트워크 서비스(LG Telecom)", "url": "/posts/kynax-004/", "categories": "", "tags": "", "date": "2003-01-01 09:00:00 +0900", "snippet": "홈 네트워크 서비스(LG Telecom) 기간 : 2003.01 ~ 2003.02■ 사용 기술 역활 : 응용SW개발 시스템 환경 : Windows, Oracle 사용 기술 : WAP(Wireless Application Protocol), xHTML LG 가전제품을 핸드폰을 이용하여 원격에서 제어할 수 있는 서비스 구축." }, { "title": "CP 통계 페이지 관리/ONM서버 관리용 추이 프로그램 개발", "url": "/posts/kynax-003/", "categories": "", "tags": "", "date": "2002-08-01 09:00:00 +0900", "snippet": "CP 통계 페이지 관리/ONM서버 관리용 추이 프로그램 개발 기간 : 2002.08 ~ 2003.08SKT / PlayOn (파견)■ 사용 기술 역활 : 응용SW개발, IT시스템관리 시스템 환경 : LINUX, Windows, Apache, Oracle 사용 기술 : C++, PHP, HTML HDSS와 HOSS 서버에서 로그를 다운로드하여 총건수, 다운로드 실패건수, CDS 서버 접속실패 건수, 현재 완료율등을 표시하는 추이도 프로그램 개발하고 CP 통계 페이지를 관리함. 참고 ** HDSS : High-media Download Service System (과금자료생성/컨텐츠 다운로드 서버 중계) ** HOSS : High-media Online application Service System (사용자 인증/통계자료생성/Online Data 중계) ** HCDS : High-media Contents Download System (GVM, SK-VM 다운로드 서버/통계 자료 생성)" }, { "title": "SM발송 프로그램", "url": "/posts/kynax-002/", "categories": "", "tags": "", "date": "2002-05-01 09:00:00 +0900", "snippet": "SM발송 프로그램 기간 : 2002.05.27 ~ 2002.08.19 (PDA용 SMS 발송 프로그램) 2002.07.02 ~ 2002.07.09 (SMS 관리 프로그램) 2002.11.05 ~ 2003.01.13 (TRIS-2 Client)—■ 사용 기술 역활 : 응용 SW 개발 시스템 환경 : Windows 사용 기술 : C++, eVC++ PDA용 SMS 발송 프로그램 : PDA에서 단문 메시지(SMS)를 발송할 수 있도록 돕는 앱. SMS 관리 프로그램 : CP(컨텐츠 프로바이더)들이 관리하는 그룹 또는 사용자에게 SMS 메시지를 발송하기 위한 프로그램. TRIS-2 Clent : TRIS-2의 자바 클라이언트의 문제점 해소를 위해 TRIS-2 클라이언트를 MFC로 개발하게 되었으며, 사용자에게 더 편리한 인터페이스를 제공함. " }, { "title": "웹 이미지 편집툴", "url": "/posts/kynax-001/", "categories": "", "tags": "", "date": "2002-03-01 09:00:00 +0900", "snippet": "웹 이미지 편집툴 기간 : 2002.03 ~ 2002.04■ 사용 기술 역활 : 응용 SW 개발 시스템 환경 : Windows 사용 기술 : C++ ActiveX로 구현하여 웹에서 이미지를 편집할 수 있도록 개발함. 이미지 반전 이미지 밝기 대조(대치) Blur, Sharpen, Out-Line(Laplacian), Embossing 상하좌우 반전, 좌우 90도 회전 이미지 잘라내기" }, { "title": "다자간 화상회의 시스템", "url": "/posts/mnj-003/", "categories": "", "tags": "", "date": "2001-08-01 09:00:00 +0900", "snippet": "다자간 화상회의 시스템 기간 : 2001.08 ~ 2002.02■ 사용 기술 역활 : 응용 SW 개발 시스템 환경 : UNIX, Windows, x86, Apache 사용 기술 : C++, PHP, HTML, SQL 넷캠과 마이크를 이용하여 최대 8명까지 수용 가능한 화상회의 시스템을 개발하였으며, JPEG(mjpeg)와 G.723을 이용하여 개발함. 음성의 경우 마이크의 활성/비활성화를 통해 한 사람만 이용하도록 개발함.(* 넷캠과 웹캠의 차이는 자체적으로 IP를 할당 받을 수 있느냐 없느냐의 차이이며, 웹캠의 경우 항상 PC등의 매개체가 존재하여야 함.)" }, { "title": "화상회의 시스템 개발", "url": "/posts/mnj-002/", "categories": "", "tags": "", "date": "2001-04-01 09:00:00 +0900", "snippet": "화상회의 시스템 개발 기간 : 2001.04 ~ 2001.07■ 사용 기술 역활 : 응용 SW 개발 시스템 환경 : UNIX, Windows, x86 사용 기술 : C++, PHP, MYSQL 웹캠과 마이크를 이용하여 최대 8명까지 수용 가능한 화상회의 시스템을 개발하였으며, JPEG(mjpeg)와 G.723을 이용하여 ActiveX로 개발함. 음성의 경우 마이크의 활성/비활성화를 통해 한 사람만 이용하도록 개발함." }, { "title": "아카이빙 서버 운영", "url": "/posts/mnj-001/", "categories": "", "tags": "", "date": "2000-10-01 09:00:00 +0900", "snippet": "NetCam/Server Sound 서버 운영 기간 : 2000.10 ~ 2001.03■ 사용 기술 역활 : 응용 SW 개발 시스템 환경 : UNIX, Linux, Apache 사용 기술 : C++, PHP, HTML, MYSQL 사운드(음원)에 대한 아카이빙 서버 운영(보관/검색/다운로드) 및 자체 개발한 네트워크 카메라의 수집 영상을 보관/활용하는 서버의 운영을 담당했으며, 웹 언어를 이용하여 사용자들에게 접근의 편의를 제공함." } ]
